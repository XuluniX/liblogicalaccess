// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: iks.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_iks_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_iks_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_iks_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_iks_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[14]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_iks_2eproto;
class CMSG_AESOperation;
struct CMSG_AESOperationDefaultTypeInternal;
extern CMSG_AESOperationDefaultTypeInternal _CMSG_AESOperation_default_instance_;
class CMSG_DesfireAESAuth_Step1;
struct CMSG_DesfireAESAuth_Step1DefaultTypeInternal;
extern CMSG_DesfireAESAuth_Step1DefaultTypeInternal _CMSG_DesfireAESAuth_Step1_default_instance_;
class CMSG_DesfireAuth_Step2;
struct CMSG_DesfireAuth_Step2DefaultTypeInternal;
extern CMSG_DesfireAuth_Step2DefaultTypeInternal _CMSG_DesfireAuth_Step2_default_instance_;
class CMSG_DesfireChangeKey;
struct CMSG_DesfireChangeKeyDefaultTypeInternal;
extern CMSG_DesfireChangeKeyDefaultTypeInternal _CMSG_DesfireChangeKey_default_instance_;
class CMSG_DesfireISOAuth_Step1;
struct CMSG_DesfireISOAuth_Step1DefaultTypeInternal;
extern CMSG_DesfireISOAuth_Step1DefaultTypeInternal _CMSG_DesfireISOAuth_Step1_default_instance_;
class CMSG_GenRandom;
struct CMSG_GenRandomDefaultTypeInternal;
extern CMSG_GenRandomDefaultTypeInternal _CMSG_GenRandom_default_instance_;
class KeyDiversificationInfo;
struct KeyDiversificationInfoDefaultTypeInternal;
extern KeyDiversificationInfoDefaultTypeInternal _KeyDiversificationInfo_default_instance_;
class SMSG_AESResult;
struct SMSG_AESResultDefaultTypeInternal;
extern SMSG_AESResultDefaultTypeInternal _SMSG_AESResult_default_instance_;
class SMSG_DesfireAESAuth_Step1;
struct SMSG_DesfireAESAuth_Step1DefaultTypeInternal;
extern SMSG_DesfireAESAuth_Step1DefaultTypeInternal _SMSG_DesfireAESAuth_Step1_default_instance_;
class SMSG_DesfireAuth_Step2;
struct SMSG_DesfireAuth_Step2DefaultTypeInternal;
extern SMSG_DesfireAuth_Step2DefaultTypeInternal _SMSG_DesfireAuth_Step2_default_instance_;
class SMSG_DesfireChangeKey;
struct SMSG_DesfireChangeKeyDefaultTypeInternal;
extern SMSG_DesfireChangeKeyDefaultTypeInternal _SMSG_DesfireChangeKey_default_instance_;
class SMSG_DesfireISOAuth_Step1;
struct SMSG_DesfireISOAuth_Step1DefaultTypeInternal;
extern SMSG_DesfireISOAuth_Step1DefaultTypeInternal _SMSG_DesfireISOAuth_Step1_default_instance_;
class SMSG_GenRandom;
struct SMSG_GenRandomDefaultTypeInternal;
extern SMSG_GenRandomDefaultTypeInternal _SMSG_GenRandom_default_instance_;
class SignatureDescription;
struct SignatureDescriptionDefaultTypeInternal;
extern SignatureDescriptionDefaultTypeInternal _SignatureDescription_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::CMSG_AESOperation* Arena::CreateMaybeMessage<::CMSG_AESOperation>(Arena*);
template<> ::CMSG_DesfireAESAuth_Step1* Arena::CreateMaybeMessage<::CMSG_DesfireAESAuth_Step1>(Arena*);
template<> ::CMSG_DesfireAuth_Step2* Arena::CreateMaybeMessage<::CMSG_DesfireAuth_Step2>(Arena*);
template<> ::CMSG_DesfireChangeKey* Arena::CreateMaybeMessage<::CMSG_DesfireChangeKey>(Arena*);
template<> ::CMSG_DesfireISOAuth_Step1* Arena::CreateMaybeMessage<::CMSG_DesfireISOAuth_Step1>(Arena*);
template<> ::CMSG_GenRandom* Arena::CreateMaybeMessage<::CMSG_GenRandom>(Arena*);
template<> ::KeyDiversificationInfo* Arena::CreateMaybeMessage<::KeyDiversificationInfo>(Arena*);
template<> ::SMSG_AESResult* Arena::CreateMaybeMessage<::SMSG_AESResult>(Arena*);
template<> ::SMSG_DesfireAESAuth_Step1* Arena::CreateMaybeMessage<::SMSG_DesfireAESAuth_Step1>(Arena*);
template<> ::SMSG_DesfireAuth_Step2* Arena::CreateMaybeMessage<::SMSG_DesfireAuth_Step2>(Arena*);
template<> ::SMSG_DesfireChangeKey* Arena::CreateMaybeMessage<::SMSG_DesfireChangeKey>(Arena*);
template<> ::SMSG_DesfireISOAuth_Step1* Arena::CreateMaybeMessage<::SMSG_DesfireISOAuth_Step1>(Arena*);
template<> ::SMSG_GenRandom* Arena::CreateMaybeMessage<::SMSG_GenRandom>(Arena*);
template<> ::SignatureDescription* Arena::CreateMaybeMessage<::SignatureDescription>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum KeyDiversificationInfo_Type : int {
  KeyDiversificationInfo_Type_NONE = 0,
  KeyDiversificationInfo_Type_AV2 = 2,
  KeyDiversificationInfo_Type_KeyDiversificationInfo_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  KeyDiversificationInfo_Type_KeyDiversificationInfo_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool KeyDiversificationInfo_Type_IsValid(int value);
constexpr KeyDiversificationInfo_Type KeyDiversificationInfo_Type_Type_MIN = KeyDiversificationInfo_Type_NONE;
constexpr KeyDiversificationInfo_Type KeyDiversificationInfo_Type_Type_MAX = KeyDiversificationInfo_Type_AV2;
constexpr int KeyDiversificationInfo_Type_Type_ARRAYSIZE = KeyDiversificationInfo_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* KeyDiversificationInfo_Type_descriptor();
template<typename T>
inline const std::string& KeyDiversificationInfo_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, KeyDiversificationInfo_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function KeyDiversificationInfo_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    KeyDiversificationInfo_Type_descriptor(), enum_t_value);
}
inline bool KeyDiversificationInfo_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, KeyDiversificationInfo_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<KeyDiversificationInfo_Type>(
    KeyDiversificationInfo_Type_descriptor(), name, value);
}
// ===================================================================

class KeyDiversificationInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:KeyDiversificationInfo) */ {
 public:
  inline KeyDiversificationInfo() : KeyDiversificationInfo(nullptr) {}
  ~KeyDiversificationInfo() override;
  explicit constexpr KeyDiversificationInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KeyDiversificationInfo(const KeyDiversificationInfo& from);
  KeyDiversificationInfo(KeyDiversificationInfo&& from) noexcept
    : KeyDiversificationInfo() {
    *this = ::std::move(from);
  }

  inline KeyDiversificationInfo& operator=(const KeyDiversificationInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyDiversificationInfo& operator=(KeyDiversificationInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeyDiversificationInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeyDiversificationInfo* internal_default_instance() {
    return reinterpret_cast<const KeyDiversificationInfo*>(
               &_KeyDiversificationInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(KeyDiversificationInfo& a, KeyDiversificationInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(KeyDiversificationInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyDiversificationInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline KeyDiversificationInfo* New() const final {
    return new KeyDiversificationInfo();
  }

  KeyDiversificationInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<KeyDiversificationInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const KeyDiversificationInfo& from);
  void MergeFrom(const KeyDiversificationInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyDiversificationInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "KeyDiversificationInfo";
  }
  protected:
  explicit KeyDiversificationInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef KeyDiversificationInfo_Type Type;
  static constexpr Type NONE =
    KeyDiversificationInfo_Type_NONE;
  static constexpr Type AV2 =
    KeyDiversificationInfo_Type_AV2;
  static inline bool Type_IsValid(int value) {
    return KeyDiversificationInfo_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    KeyDiversificationInfo_Type_Type_MIN;
  static constexpr Type Type_MAX =
    KeyDiversificationInfo_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    KeyDiversificationInfo_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return KeyDiversificationInfo_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return KeyDiversificationInfo_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return KeyDiversificationInfo_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDivInputFieldNumber = 2,
    kDivTypeFieldNumber = 1,
  };
  // bytes div_input = 2;
  void clear_div_input();
  const std::string& div_input() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_div_input(ArgT0&& arg0, ArgT... args);
  std::string* mutable_div_input();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_div_input();
  void set_allocated_div_input(std::string* div_input);
  private:
  const std::string& _internal_div_input() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_div_input(const std::string& value);
  std::string* _internal_mutable_div_input();
  public:

  // .KeyDiversificationInfo.Type div_type = 1;
  void clear_div_type();
  ::KeyDiversificationInfo_Type div_type() const;
  void set_div_type(::KeyDiversificationInfo_Type value);
  private:
  ::KeyDiversificationInfo_Type _internal_div_type() const;
  void _internal_set_div_type(::KeyDiversificationInfo_Type value);
  public:

  // @@protoc_insertion_point(class_scope:KeyDiversificationInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr div_input_;
  int div_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_iks_2eproto;
};
// -------------------------------------------------------------------

class SignatureDescription final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SignatureDescription) */ {
 public:
  inline SignatureDescription() : SignatureDescription(nullptr) {}
  ~SignatureDescription() override;
  explicit constexpr SignatureDescription(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SignatureDescription(const SignatureDescription& from);
  SignatureDescription(SignatureDescription&& from) noexcept
    : SignatureDescription() {
    *this = ::std::move(from);
  }

  inline SignatureDescription& operator=(const SignatureDescription& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignatureDescription& operator=(SignatureDescription&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignatureDescription& default_instance() {
    return *internal_default_instance();
  }
  static inline const SignatureDescription* internal_default_instance() {
    return reinterpret_cast<const SignatureDescription*>(
               &_SignatureDescription_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SignatureDescription& a, SignatureDescription& b) {
    a.Swap(&b);
  }
  inline void Swap(SignatureDescription* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignatureDescription* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SignatureDescription* New() const final {
    return new SignatureDescription();
  }

  SignatureDescription* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SignatureDescription>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SignatureDescription& from);
  void MergeFrom(const SignatureDescription& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignatureDescription* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SignatureDescription";
  }
  protected:
  explicit SignatureDescription(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadFieldNumber = 1,
    kRunUuidFieldNumber = 3,
    kNonceFieldNumber = 2,
    kTimestampFieldNumber = 4,
  };
  // bytes payload = 1;
  void clear_payload();
  const std::string& payload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payload();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_payload();
  void set_allocated_payload(std::string* payload);
  private:
  const std::string& _internal_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload(const std::string& value);
  std::string* _internal_mutable_payload();
  public:

  // bytes run_uuid = 3;
  void clear_run_uuid();
  const std::string& run_uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_run_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_run_uuid();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_run_uuid();
  void set_allocated_run_uuid(std::string* run_uuid);
  private:
  const std::string& _internal_run_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_run_uuid(const std::string& value);
  std::string* _internal_mutable_run_uuid();
  public:

  // uint64 nonce = 2;
  void clear_nonce();
  ::PROTOBUF_NAMESPACE_ID::uint64 nonce() const;
  void set_nonce(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_nonce() const;
  void _internal_set_nonce(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 timestamp = 4;
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::uint64 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_timestamp() const;
  void _internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:SignatureDescription)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr run_uuid_;
  ::PROTOBUF_NAMESPACE_ID::uint64 nonce_;
  ::PROTOBUF_NAMESPACE_ID::uint64 timestamp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_iks_2eproto;
};
// -------------------------------------------------------------------

class CMSG_DesfireChangeKey final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMSG_DesfireChangeKey) */ {
 public:
  inline CMSG_DesfireChangeKey() : CMSG_DesfireChangeKey(nullptr) {}
  ~CMSG_DesfireChangeKey() override;
  explicit constexpr CMSG_DesfireChangeKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMSG_DesfireChangeKey(const CMSG_DesfireChangeKey& from);
  CMSG_DesfireChangeKey(CMSG_DesfireChangeKey&& from) noexcept
    : CMSG_DesfireChangeKey() {
    *this = ::std::move(from);
  }

  inline CMSG_DesfireChangeKey& operator=(const CMSG_DesfireChangeKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMSG_DesfireChangeKey& operator=(CMSG_DesfireChangeKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMSG_DesfireChangeKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMSG_DesfireChangeKey* internal_default_instance() {
    return reinterpret_cast<const CMSG_DesfireChangeKey*>(
               &_CMSG_DesfireChangeKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CMSG_DesfireChangeKey& a, CMSG_DesfireChangeKey& b) {
    a.Swap(&b);
  }
  inline void Swap(CMSG_DesfireChangeKey* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMSG_DesfireChangeKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CMSG_DesfireChangeKey* New() const final {
    return new CMSG_DesfireChangeKey();
  }

  CMSG_DesfireChangeKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CMSG_DesfireChangeKey>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CMSG_DesfireChangeKey& from);
  void MergeFrom(const CMSG_DesfireChangeKey& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMSG_DesfireChangeKey* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMSG_DesfireChangeKey";
  }
  protected:
  explicit CMSG_DesfireChangeKey(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOldKeyUuidFieldNumber = 1,
    kOldKeyBytesFieldNumber = 2,
    kNewKeyUuidFieldNumber = 3,
    kNewKeyBytesFieldNumber = 4,
    kSessionKeyUuidFieldNumber = 6,
    kSessionKeyFieldNumber = 7,
    kIvFieldNumber = 11,
    kOldKeyDivFieldNumber = 8,
    kNewKeyDivFieldNumber = 9,
    kChangeSameKeyFieldNumber = 5,
    kKeyNumberFieldNumber = 10,
  };
  // string old_key_uuid = 1;
  void clear_old_key_uuid();
  const std::string& old_key_uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_old_key_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_old_key_uuid();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_old_key_uuid();
  void set_allocated_old_key_uuid(std::string* old_key_uuid);
  private:
  const std::string& _internal_old_key_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_old_key_uuid(const std::string& value);
  std::string* _internal_mutable_old_key_uuid();
  public:

  // bytes old_key_bytes = 2;
  void clear_old_key_bytes();
  const std::string& old_key_bytes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_old_key_bytes(ArgT0&& arg0, ArgT... args);
  std::string* mutable_old_key_bytes();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_old_key_bytes();
  void set_allocated_old_key_bytes(std::string* old_key_bytes);
  private:
  const std::string& _internal_old_key_bytes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_old_key_bytes(const std::string& value);
  std::string* _internal_mutable_old_key_bytes();
  public:

  // string new_key_uuid = 3;
  void clear_new_key_uuid();
  const std::string& new_key_uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_key_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_key_uuid();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_new_key_uuid();
  void set_allocated_new_key_uuid(std::string* new_key_uuid);
  private:
  const std::string& _internal_new_key_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_key_uuid(const std::string& value);
  std::string* _internal_mutable_new_key_uuid();
  public:

  // bytes new_key_bytes = 4;
  void clear_new_key_bytes();
  const std::string& new_key_bytes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_key_bytes(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_key_bytes();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_new_key_bytes();
  void set_allocated_new_key_bytes(std::string* new_key_bytes);
  private:
  const std::string& _internal_new_key_bytes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_key_bytes(const std::string& value);
  std::string* _internal_mutable_new_key_bytes();
  public:

  // string session_key_uuid = 6;
  void clear_session_key_uuid();
  const std::string& session_key_uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session_key_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session_key_uuid();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_session_key_uuid();
  void set_allocated_session_key_uuid(std::string* session_key_uuid);
  private:
  const std::string& _internal_session_key_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_key_uuid(const std::string& value);
  std::string* _internal_mutable_session_key_uuid();
  public:

  // bytes session_key = 7;
  void clear_session_key();
  const std::string& session_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session_key();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_session_key();
  void set_allocated_session_key(std::string* session_key);
  private:
  const std::string& _internal_session_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_key(const std::string& value);
  std::string* _internal_mutable_session_key();
  public:

  // bytes iv = 11;
  void clear_iv();
  const std::string& iv() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_iv(ArgT0&& arg0, ArgT... args);
  std::string* mutable_iv();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_iv();
  void set_allocated_iv(std::string* iv);
  private:
  const std::string& _internal_iv() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_iv(const std::string& value);
  std::string* _internal_mutable_iv();
  public:

  // .KeyDiversificationInfo old_key_div = 8;
  bool has_old_key_div() const;
  private:
  bool _internal_has_old_key_div() const;
  public:
  void clear_old_key_div();
  const ::KeyDiversificationInfo& old_key_div() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::KeyDiversificationInfo* release_old_key_div();
  ::KeyDiversificationInfo* mutable_old_key_div();
  void set_allocated_old_key_div(::KeyDiversificationInfo* old_key_div);
  private:
  const ::KeyDiversificationInfo& _internal_old_key_div() const;
  ::KeyDiversificationInfo* _internal_mutable_old_key_div();
  public:
  void unsafe_arena_set_allocated_old_key_div(
      ::KeyDiversificationInfo* old_key_div);
  ::KeyDiversificationInfo* unsafe_arena_release_old_key_div();

  // .KeyDiversificationInfo new_key_div = 9;
  bool has_new_key_div() const;
  private:
  bool _internal_has_new_key_div() const;
  public:
  void clear_new_key_div();
  const ::KeyDiversificationInfo& new_key_div() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::KeyDiversificationInfo* release_new_key_div();
  ::KeyDiversificationInfo* mutable_new_key_div();
  void set_allocated_new_key_div(::KeyDiversificationInfo* new_key_div);
  private:
  const ::KeyDiversificationInfo& _internal_new_key_div() const;
  ::KeyDiversificationInfo* _internal_mutable_new_key_div();
  public:
  void unsafe_arena_set_allocated_new_key_div(
      ::KeyDiversificationInfo* new_key_div);
  ::KeyDiversificationInfo* unsafe_arena_release_new_key_div();

  // bool change_same_key = 5;
  void clear_change_same_key();
  bool change_same_key() const;
  void set_change_same_key(bool value);
  private:
  bool _internal_change_same_key() const;
  void _internal_set_change_same_key(bool value);
  public:

  // int32 key_number = 10;
  void clear_key_number();
  ::PROTOBUF_NAMESPACE_ID::int32 key_number() const;
  void set_key_number(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_key_number() const;
  void _internal_set_key_number(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:CMSG_DesfireChangeKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr old_key_uuid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr old_key_bytes_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_key_uuid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_key_bytes_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_key_uuid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr iv_;
  ::KeyDiversificationInfo* old_key_div_;
  ::KeyDiversificationInfo* new_key_div_;
  bool change_same_key_;
  ::PROTOBUF_NAMESPACE_ID::int32 key_number_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_iks_2eproto;
};
// -------------------------------------------------------------------

class SMSG_DesfireChangeKey final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SMSG_DesfireChangeKey) */ {
 public:
  inline SMSG_DesfireChangeKey() : SMSG_DesfireChangeKey(nullptr) {}
  ~SMSG_DesfireChangeKey() override;
  explicit constexpr SMSG_DesfireChangeKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SMSG_DesfireChangeKey(const SMSG_DesfireChangeKey& from);
  SMSG_DesfireChangeKey(SMSG_DesfireChangeKey&& from) noexcept
    : SMSG_DesfireChangeKey() {
    *this = ::std::move(from);
  }

  inline SMSG_DesfireChangeKey& operator=(const SMSG_DesfireChangeKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline SMSG_DesfireChangeKey& operator=(SMSG_DesfireChangeKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SMSG_DesfireChangeKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const SMSG_DesfireChangeKey* internal_default_instance() {
    return reinterpret_cast<const SMSG_DesfireChangeKey*>(
               &_SMSG_DesfireChangeKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SMSG_DesfireChangeKey& a, SMSG_DesfireChangeKey& b) {
    a.Swap(&b);
  }
  inline void Swap(SMSG_DesfireChangeKey* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SMSG_DesfireChangeKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SMSG_DesfireChangeKey* New() const final {
    return new SMSG_DesfireChangeKey();
  }

  SMSG_DesfireChangeKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SMSG_DesfireChangeKey>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SMSG_DesfireChangeKey& from);
  void MergeFrom(const SMSG_DesfireChangeKey& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SMSG_DesfireChangeKey* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SMSG_DesfireChangeKey";
  }
  protected:
  explicit SMSG_DesfireChangeKey(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCryptogramFieldNumber = 1,
  };
  // bytes cryptogram = 1;
  void clear_cryptogram();
  const std::string& cryptogram() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cryptogram(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cryptogram();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_cryptogram();
  void set_allocated_cryptogram(std::string* cryptogram);
  private:
  const std::string& _internal_cryptogram() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cryptogram(const std::string& value);
  std::string* _internal_mutable_cryptogram();
  public:

  // @@protoc_insertion_point(class_scope:SMSG_DesfireChangeKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cryptogram_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_iks_2eproto;
};
// -------------------------------------------------------------------

class CMSG_GenRandom final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMSG_GenRandom) */ {
 public:
  inline CMSG_GenRandom() : CMSG_GenRandom(nullptr) {}
  ~CMSG_GenRandom() override;
  explicit constexpr CMSG_GenRandom(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMSG_GenRandom(const CMSG_GenRandom& from);
  CMSG_GenRandom(CMSG_GenRandom&& from) noexcept
    : CMSG_GenRandom() {
    *this = ::std::move(from);
  }

  inline CMSG_GenRandom& operator=(const CMSG_GenRandom& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMSG_GenRandom& operator=(CMSG_GenRandom&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMSG_GenRandom& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMSG_GenRandom* internal_default_instance() {
    return reinterpret_cast<const CMSG_GenRandom*>(
               &_CMSG_GenRandom_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CMSG_GenRandom& a, CMSG_GenRandom& b) {
    a.Swap(&b);
  }
  inline void Swap(CMSG_GenRandom* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMSG_GenRandom* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CMSG_GenRandom* New() const final {
    return new CMSG_GenRandom();
  }

  CMSG_GenRandom* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CMSG_GenRandom>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CMSG_GenRandom& from);
  void MergeFrom(const CMSG_GenRandom& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMSG_GenRandom* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMSG_GenRandom";
  }
  protected:
  explicit CMSG_GenRandom(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSizeFieldNumber = 1,
  };
  // int32 size = 1;
  void clear_size();
  ::PROTOBUF_NAMESPACE_ID::int32 size() const;
  void set_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_size() const;
  void _internal_set_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:CMSG_GenRandom)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_iks_2eproto;
};
// -------------------------------------------------------------------

class SMSG_GenRandom final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SMSG_GenRandom) */ {
 public:
  inline SMSG_GenRandom() : SMSG_GenRandom(nullptr) {}
  ~SMSG_GenRandom() override;
  explicit constexpr SMSG_GenRandom(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SMSG_GenRandom(const SMSG_GenRandom& from);
  SMSG_GenRandom(SMSG_GenRandom&& from) noexcept
    : SMSG_GenRandom() {
    *this = ::std::move(from);
  }

  inline SMSG_GenRandom& operator=(const SMSG_GenRandom& from) {
    CopyFrom(from);
    return *this;
  }
  inline SMSG_GenRandom& operator=(SMSG_GenRandom&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SMSG_GenRandom& default_instance() {
    return *internal_default_instance();
  }
  static inline const SMSG_GenRandom* internal_default_instance() {
    return reinterpret_cast<const SMSG_GenRandom*>(
               &_SMSG_GenRandom_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SMSG_GenRandom& a, SMSG_GenRandom& b) {
    a.Swap(&b);
  }
  inline void Swap(SMSG_GenRandom* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SMSG_GenRandom* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SMSG_GenRandom* New() const final {
    return new SMSG_GenRandom();
  }

  SMSG_GenRandom* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SMSG_GenRandom>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SMSG_GenRandom& from);
  void MergeFrom(const SMSG_GenRandom& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SMSG_GenRandom* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SMSG_GenRandom";
  }
  protected:
  explicit SMSG_GenRandom(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRandomBytesFieldNumber = 1,
  };
  // bytes randomBytes = 1;
  void clear_randombytes();
  const std::string& randombytes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_randombytes(ArgT0&& arg0, ArgT... args);
  std::string* mutable_randombytes();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_randombytes();
  void set_allocated_randombytes(std::string* randombytes);
  private:
  const std::string& _internal_randombytes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_randombytes(const std::string& value);
  std::string* _internal_mutable_randombytes();
  public:

  // @@protoc_insertion_point(class_scope:SMSG_GenRandom)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr randombytes_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_iks_2eproto;
};
// -------------------------------------------------------------------

class CMSG_AESOperation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMSG_AESOperation) */ {
 public:
  inline CMSG_AESOperation() : CMSG_AESOperation(nullptr) {}
  ~CMSG_AESOperation() override;
  explicit constexpr CMSG_AESOperation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMSG_AESOperation(const CMSG_AESOperation& from);
  CMSG_AESOperation(CMSG_AESOperation&& from) noexcept
    : CMSG_AESOperation() {
    *this = ::std::move(from);
  }

  inline CMSG_AESOperation& operator=(const CMSG_AESOperation& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMSG_AESOperation& operator=(CMSG_AESOperation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMSG_AESOperation& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMSG_AESOperation* internal_default_instance() {
    return reinterpret_cast<const CMSG_AESOperation*>(
               &_CMSG_AESOperation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(CMSG_AESOperation& a, CMSG_AESOperation& b) {
    a.Swap(&b);
  }
  inline void Swap(CMSG_AESOperation* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMSG_AESOperation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CMSG_AESOperation* New() const final {
    return new CMSG_AESOperation();
  }

  CMSG_AESOperation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CMSG_AESOperation>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CMSG_AESOperation& from);
  void MergeFrom(const CMSG_AESOperation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMSG_AESOperation* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMSG_AESOperation";
  }
  protected:
  explicit CMSG_AESOperation(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyUuidFieldNumber = 1,
    kPayloadFieldNumber = 3,
    kIvFieldNumber = 4,
    kDiversificationFieldNumber = 6,
    kRequestSignatureFieldNumber = 5,
  };
  // string key_uuid = 1;
  void clear_key_uuid();
  const std::string& key_uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key_uuid();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_key_uuid();
  void set_allocated_key_uuid(std::string* key_uuid);
  private:
  const std::string& _internal_key_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key_uuid(const std::string& value);
  std::string* _internal_mutable_key_uuid();
  public:

  // bytes payload = 3;
  void clear_payload();
  const std::string& payload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payload();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_payload();
  void set_allocated_payload(std::string* payload);
  private:
  const std::string& _internal_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload(const std::string& value);
  std::string* _internal_mutable_payload();
  public:

  // bytes iv = 4;
  void clear_iv();
  const std::string& iv() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_iv(ArgT0&& arg0, ArgT... args);
  std::string* mutable_iv();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_iv();
  void set_allocated_iv(std::string* iv);
  private:
  const std::string& _internal_iv() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_iv(const std::string& value);
  std::string* _internal_mutable_iv();
  public:

  // .KeyDiversificationInfo diversification = 6;
  bool has_diversification() const;
  private:
  bool _internal_has_diversification() const;
  public:
  void clear_diversification();
  const ::KeyDiversificationInfo& diversification() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::KeyDiversificationInfo* release_diversification();
  ::KeyDiversificationInfo* mutable_diversification();
  void set_allocated_diversification(::KeyDiversificationInfo* diversification);
  private:
  const ::KeyDiversificationInfo& _internal_diversification() const;
  ::KeyDiversificationInfo* _internal_mutable_diversification();
  public:
  void unsafe_arena_set_allocated_diversification(
      ::KeyDiversificationInfo* diversification);
  ::KeyDiversificationInfo* unsafe_arena_release_diversification();

  // bool request_signature = 5;
  void clear_request_signature();
  bool request_signature() const;
  void set_request_signature(bool value);
  private:
  bool _internal_request_signature() const;
  void _internal_set_request_signature(bool value);
  public:

  // @@protoc_insertion_point(class_scope:CMSG_AESOperation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_uuid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr iv_;
  ::KeyDiversificationInfo* diversification_;
  bool request_signature_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_iks_2eproto;
};
// -------------------------------------------------------------------

class SMSG_AESResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SMSG_AESResult) */ {
 public:
  inline SMSG_AESResult() : SMSG_AESResult(nullptr) {}
  ~SMSG_AESResult() override;
  explicit constexpr SMSG_AESResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SMSG_AESResult(const SMSG_AESResult& from);
  SMSG_AESResult(SMSG_AESResult&& from) noexcept
    : SMSG_AESResult() {
    *this = ::std::move(from);
  }

  inline SMSG_AESResult& operator=(const SMSG_AESResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline SMSG_AESResult& operator=(SMSG_AESResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SMSG_AESResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const SMSG_AESResult* internal_default_instance() {
    return reinterpret_cast<const SMSG_AESResult*>(
               &_SMSG_AESResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SMSG_AESResult& a, SMSG_AESResult& b) {
    a.Swap(&b);
  }
  inline void Swap(SMSG_AESResult* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SMSG_AESResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SMSG_AESResult* New() const final {
    return new SMSG_AESResult();
  }

  SMSG_AESResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SMSG_AESResult>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SMSG_AESResult& from);
  void MergeFrom(const SMSG_AESResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SMSG_AESResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SMSG_AESResult";
  }
  protected:
  explicit SMSG_AESResult(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadFieldNumber = 1,
    kSignatureFieldNumber = 3,
    kSignatureDescriptionFieldNumber = 2,
  };
  // bytes payload = 1;
  void clear_payload();
  const std::string& payload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payload();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_payload();
  void set_allocated_payload(std::string* payload);
  private:
  const std::string& _internal_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload(const std::string& value);
  std::string* _internal_mutable_payload();
  public:

  // bytes signature = 3;
  void clear_signature();
  const std::string& signature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signature();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // .SignatureDescription signatureDescription = 2;
  bool has_signaturedescription() const;
  private:
  bool _internal_has_signaturedescription() const;
  public:
  void clear_signaturedescription();
  const ::SignatureDescription& signaturedescription() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::SignatureDescription* release_signaturedescription();
  ::SignatureDescription* mutable_signaturedescription();
  void set_allocated_signaturedescription(::SignatureDescription* signaturedescription);
  private:
  const ::SignatureDescription& _internal_signaturedescription() const;
  ::SignatureDescription* _internal_mutable_signaturedescription();
  public:
  void unsafe_arena_set_allocated_signaturedescription(
      ::SignatureDescription* signaturedescription);
  ::SignatureDescription* unsafe_arena_release_signaturedescription();

  // @@protoc_insertion_point(class_scope:SMSG_AESResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
  ::SignatureDescription* signaturedescription_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_iks_2eproto;
};
// -------------------------------------------------------------------

class CMSG_DesfireAESAuth_Step1 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMSG_DesfireAESAuth_Step1) */ {
 public:
  inline CMSG_DesfireAESAuth_Step1() : CMSG_DesfireAESAuth_Step1(nullptr) {}
  ~CMSG_DesfireAESAuth_Step1() override;
  explicit constexpr CMSG_DesfireAESAuth_Step1(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMSG_DesfireAESAuth_Step1(const CMSG_DesfireAESAuth_Step1& from);
  CMSG_DesfireAESAuth_Step1(CMSG_DesfireAESAuth_Step1&& from) noexcept
    : CMSG_DesfireAESAuth_Step1() {
    *this = ::std::move(from);
  }

  inline CMSG_DesfireAESAuth_Step1& operator=(const CMSG_DesfireAESAuth_Step1& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMSG_DesfireAESAuth_Step1& operator=(CMSG_DesfireAESAuth_Step1&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMSG_DesfireAESAuth_Step1& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMSG_DesfireAESAuth_Step1* internal_default_instance() {
    return reinterpret_cast<const CMSG_DesfireAESAuth_Step1*>(
               &_CMSG_DesfireAESAuth_Step1_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CMSG_DesfireAESAuth_Step1& a, CMSG_DesfireAESAuth_Step1& b) {
    a.Swap(&b);
  }
  inline void Swap(CMSG_DesfireAESAuth_Step1* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMSG_DesfireAESAuth_Step1* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CMSG_DesfireAESAuth_Step1* New() const final {
    return new CMSG_DesfireAESAuth_Step1();
  }

  CMSG_DesfireAESAuth_Step1* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CMSG_DesfireAESAuth_Step1>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CMSG_DesfireAESAuth_Step1& from);
  void MergeFrom(const CMSG_DesfireAESAuth_Step1& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMSG_DesfireAESAuth_Step1* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMSG_DesfireAESAuth_Step1";
  }
  protected:
  explicit CMSG_DesfireAESAuth_Step1(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyUuidFieldNumber = 1,
    kEncryptedRandomPiccFieldNumber = 2,
    kDiversificationFieldNumber = 3,
  };
  // string key_uuid = 1;
  void clear_key_uuid();
  const std::string& key_uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key_uuid();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_key_uuid();
  void set_allocated_key_uuid(std::string* key_uuid);
  private:
  const std::string& _internal_key_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key_uuid(const std::string& value);
  std::string* _internal_mutable_key_uuid();
  public:

  // bytes encrypted_random_picc = 2;
  void clear_encrypted_random_picc();
  const std::string& encrypted_random_picc() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_encrypted_random_picc(ArgT0&& arg0, ArgT... args);
  std::string* mutable_encrypted_random_picc();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_encrypted_random_picc();
  void set_allocated_encrypted_random_picc(std::string* encrypted_random_picc);
  private:
  const std::string& _internal_encrypted_random_picc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_encrypted_random_picc(const std::string& value);
  std::string* _internal_mutable_encrypted_random_picc();
  public:

  // .KeyDiversificationInfo diversification = 3;
  bool has_diversification() const;
  private:
  bool _internal_has_diversification() const;
  public:
  void clear_diversification();
  const ::KeyDiversificationInfo& diversification() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::KeyDiversificationInfo* release_diversification();
  ::KeyDiversificationInfo* mutable_diversification();
  void set_allocated_diversification(::KeyDiversificationInfo* diversification);
  private:
  const ::KeyDiversificationInfo& _internal_diversification() const;
  ::KeyDiversificationInfo* _internal_mutable_diversification();
  public:
  void unsafe_arena_set_allocated_diversification(
      ::KeyDiversificationInfo* diversification);
  ::KeyDiversificationInfo* unsafe_arena_release_diversification();

  // @@protoc_insertion_point(class_scope:CMSG_DesfireAESAuth_Step1)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_uuid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encrypted_random_picc_;
  ::KeyDiversificationInfo* diversification_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_iks_2eproto;
};
// -------------------------------------------------------------------

class SMSG_DesfireAESAuth_Step1 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SMSG_DesfireAESAuth_Step1) */ {
 public:
  inline SMSG_DesfireAESAuth_Step1() : SMSG_DesfireAESAuth_Step1(nullptr) {}
  ~SMSG_DesfireAESAuth_Step1() override;
  explicit constexpr SMSG_DesfireAESAuth_Step1(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SMSG_DesfireAESAuth_Step1(const SMSG_DesfireAESAuth_Step1& from);
  SMSG_DesfireAESAuth_Step1(SMSG_DesfireAESAuth_Step1&& from) noexcept
    : SMSG_DesfireAESAuth_Step1() {
    *this = ::std::move(from);
  }

  inline SMSG_DesfireAESAuth_Step1& operator=(const SMSG_DesfireAESAuth_Step1& from) {
    CopyFrom(from);
    return *this;
  }
  inline SMSG_DesfireAESAuth_Step1& operator=(SMSG_DesfireAESAuth_Step1&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SMSG_DesfireAESAuth_Step1& default_instance() {
    return *internal_default_instance();
  }
  static inline const SMSG_DesfireAESAuth_Step1* internal_default_instance() {
    return reinterpret_cast<const SMSG_DesfireAESAuth_Step1*>(
               &_SMSG_DesfireAESAuth_Step1_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SMSG_DesfireAESAuth_Step1& a, SMSG_DesfireAESAuth_Step1& b) {
    a.Swap(&b);
  }
  inline void Swap(SMSG_DesfireAESAuth_Step1* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SMSG_DesfireAESAuth_Step1* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SMSG_DesfireAESAuth_Step1* New() const final {
    return new SMSG_DesfireAESAuth_Step1();
  }

  SMSG_DesfireAESAuth_Step1* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SMSG_DesfireAESAuth_Step1>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SMSG_DesfireAESAuth_Step1& from);
  void MergeFrom(const SMSG_DesfireAESAuth_Step1& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SMSG_DesfireAESAuth_Step1* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SMSG_DesfireAESAuth_Step1";
  }
  protected:
  explicit SMSG_DesfireAESAuth_Step1(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEncryptedCryptogramFieldNumber = 3,
    kAuthContextIdFieldNumber = 4,
    kSuccessFieldNumber = 1,
  };
  // bytes encrypted_cryptogram = 3;
  void clear_encrypted_cryptogram();
  const std::string& encrypted_cryptogram() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_encrypted_cryptogram(ArgT0&& arg0, ArgT... args);
  std::string* mutable_encrypted_cryptogram();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_encrypted_cryptogram();
  void set_allocated_encrypted_cryptogram(std::string* encrypted_cryptogram);
  private:
  const std::string& _internal_encrypted_cryptogram() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_encrypted_cryptogram(const std::string& value);
  std::string* _internal_mutable_encrypted_cryptogram();
  public:

  // bytes auth_context_id = 4;
  void clear_auth_context_id();
  const std::string& auth_context_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_auth_context_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_auth_context_id();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_auth_context_id();
  void set_allocated_auth_context_id(std::string* auth_context_id);
  private:
  const std::string& _internal_auth_context_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_auth_context_id(const std::string& value);
  std::string* _internal_mutable_auth_context_id();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:SMSG_DesfireAESAuth_Step1)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encrypted_cryptogram_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr auth_context_id_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_iks_2eproto;
};
// -------------------------------------------------------------------

class CMSG_DesfireISOAuth_Step1 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMSG_DesfireISOAuth_Step1) */ {
 public:
  inline CMSG_DesfireISOAuth_Step1() : CMSG_DesfireISOAuth_Step1(nullptr) {}
  ~CMSG_DesfireISOAuth_Step1() override;
  explicit constexpr CMSG_DesfireISOAuth_Step1(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMSG_DesfireISOAuth_Step1(const CMSG_DesfireISOAuth_Step1& from);
  CMSG_DesfireISOAuth_Step1(CMSG_DesfireISOAuth_Step1&& from) noexcept
    : CMSG_DesfireISOAuth_Step1() {
    *this = ::std::move(from);
  }

  inline CMSG_DesfireISOAuth_Step1& operator=(const CMSG_DesfireISOAuth_Step1& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMSG_DesfireISOAuth_Step1& operator=(CMSG_DesfireISOAuth_Step1&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMSG_DesfireISOAuth_Step1& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMSG_DesfireISOAuth_Step1* internal_default_instance() {
    return reinterpret_cast<const CMSG_DesfireISOAuth_Step1*>(
               &_CMSG_DesfireISOAuth_Step1_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CMSG_DesfireISOAuth_Step1& a, CMSG_DesfireISOAuth_Step1& b) {
    a.Swap(&b);
  }
  inline void Swap(CMSG_DesfireISOAuth_Step1* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMSG_DesfireISOAuth_Step1* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CMSG_DesfireISOAuth_Step1* New() const final {
    return new CMSG_DesfireISOAuth_Step1();
  }

  CMSG_DesfireISOAuth_Step1* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CMSG_DesfireISOAuth_Step1>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CMSG_DesfireISOAuth_Step1& from);
  void MergeFrom(const CMSG_DesfireISOAuth_Step1& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMSG_DesfireISOAuth_Step1* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMSG_DesfireISOAuth_Step1";
  }
  protected:
  explicit CMSG_DesfireISOAuth_Step1(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyUuidFieldNumber = 1,
    kRandomPiccFieldNumber = 2,
    kDiversificationFieldNumber = 3,
  };
  // string key_uuid = 1;
  void clear_key_uuid();
  const std::string& key_uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key_uuid();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_key_uuid();
  void set_allocated_key_uuid(std::string* key_uuid);
  private:
  const std::string& _internal_key_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key_uuid(const std::string& value);
  std::string* _internal_mutable_key_uuid();
  public:

  // bytes random_picc = 2;
  void clear_random_picc();
  const std::string& random_picc() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_random_picc(ArgT0&& arg0, ArgT... args);
  std::string* mutable_random_picc();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_random_picc();
  void set_allocated_random_picc(std::string* random_picc);
  private:
  const std::string& _internal_random_picc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_random_picc(const std::string& value);
  std::string* _internal_mutable_random_picc();
  public:

  // .KeyDiversificationInfo diversification = 3;
  bool has_diversification() const;
  private:
  bool _internal_has_diversification() const;
  public:
  void clear_diversification();
  const ::KeyDiversificationInfo& diversification() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::KeyDiversificationInfo* release_diversification();
  ::KeyDiversificationInfo* mutable_diversification();
  void set_allocated_diversification(::KeyDiversificationInfo* diversification);
  private:
  const ::KeyDiversificationInfo& _internal_diversification() const;
  ::KeyDiversificationInfo* _internal_mutable_diversification();
  public:
  void unsafe_arena_set_allocated_diversification(
      ::KeyDiversificationInfo* diversification);
  ::KeyDiversificationInfo* unsafe_arena_release_diversification();

  // @@protoc_insertion_point(class_scope:CMSG_DesfireISOAuth_Step1)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_uuid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr random_picc_;
  ::KeyDiversificationInfo* diversification_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_iks_2eproto;
};
// -------------------------------------------------------------------

class SMSG_DesfireISOAuth_Step1 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SMSG_DesfireISOAuth_Step1) */ {
 public:
  inline SMSG_DesfireISOAuth_Step1() : SMSG_DesfireISOAuth_Step1(nullptr) {}
  ~SMSG_DesfireISOAuth_Step1() override;
  explicit constexpr SMSG_DesfireISOAuth_Step1(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SMSG_DesfireISOAuth_Step1(const SMSG_DesfireISOAuth_Step1& from);
  SMSG_DesfireISOAuth_Step1(SMSG_DesfireISOAuth_Step1&& from) noexcept
    : SMSG_DesfireISOAuth_Step1() {
    *this = ::std::move(from);
  }

  inline SMSG_DesfireISOAuth_Step1& operator=(const SMSG_DesfireISOAuth_Step1& from) {
    CopyFrom(from);
    return *this;
  }
  inline SMSG_DesfireISOAuth_Step1& operator=(SMSG_DesfireISOAuth_Step1&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SMSG_DesfireISOAuth_Step1& default_instance() {
    return *internal_default_instance();
  }
  static inline const SMSG_DesfireISOAuth_Step1* internal_default_instance() {
    return reinterpret_cast<const SMSG_DesfireISOAuth_Step1*>(
               &_SMSG_DesfireISOAuth_Step1_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SMSG_DesfireISOAuth_Step1& a, SMSG_DesfireISOAuth_Step1& b) {
    a.Swap(&b);
  }
  inline void Swap(SMSG_DesfireISOAuth_Step1* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SMSG_DesfireISOAuth_Step1* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SMSG_DesfireISOAuth_Step1* New() const final {
    return new SMSG_DesfireISOAuth_Step1();
  }

  SMSG_DesfireISOAuth_Step1* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SMSG_DesfireISOAuth_Step1>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SMSG_DesfireISOAuth_Step1& from);
  void MergeFrom(const SMSG_DesfireISOAuth_Step1& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SMSG_DesfireISOAuth_Step1* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SMSG_DesfireISOAuth_Step1";
  }
  protected:
  explicit SMSG_DesfireISOAuth_Step1(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRandom2FieldNumber = 2,
    kEncryptedCryptogramFieldNumber = 3,
    kAuthContextIdFieldNumber = 4,
    kSuccessFieldNumber = 1,
  };
  // bytes random2 = 2;
  void clear_random2();
  const std::string& random2() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_random2(ArgT0&& arg0, ArgT... args);
  std::string* mutable_random2();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_random2();
  void set_allocated_random2(std::string* random2);
  private:
  const std::string& _internal_random2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_random2(const std::string& value);
  std::string* _internal_mutable_random2();
  public:

  // bytes encrypted_cryptogram = 3;
  void clear_encrypted_cryptogram();
  const std::string& encrypted_cryptogram() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_encrypted_cryptogram(ArgT0&& arg0, ArgT... args);
  std::string* mutable_encrypted_cryptogram();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_encrypted_cryptogram();
  void set_allocated_encrypted_cryptogram(std::string* encrypted_cryptogram);
  private:
  const std::string& _internal_encrypted_cryptogram() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_encrypted_cryptogram(const std::string& value);
  std::string* _internal_mutable_encrypted_cryptogram();
  public:

  // bytes auth_context_id = 4;
  void clear_auth_context_id();
  const std::string& auth_context_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_auth_context_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_auth_context_id();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_auth_context_id();
  void set_allocated_auth_context_id(std::string* auth_context_id);
  private:
  const std::string& _internal_auth_context_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_auth_context_id(const std::string& value);
  std::string* _internal_mutable_auth_context_id();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:SMSG_DesfireISOAuth_Step1)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr random2_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encrypted_cryptogram_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr auth_context_id_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_iks_2eproto;
};
// -------------------------------------------------------------------

class CMSG_DesfireAuth_Step2 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMSG_DesfireAuth_Step2) */ {
 public:
  inline CMSG_DesfireAuth_Step2() : CMSG_DesfireAuth_Step2(nullptr) {}
  ~CMSG_DesfireAuth_Step2() override;
  explicit constexpr CMSG_DesfireAuth_Step2(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMSG_DesfireAuth_Step2(const CMSG_DesfireAuth_Step2& from);
  CMSG_DesfireAuth_Step2(CMSG_DesfireAuth_Step2&& from) noexcept
    : CMSG_DesfireAuth_Step2() {
    *this = ::std::move(from);
  }

  inline CMSG_DesfireAuth_Step2& operator=(const CMSG_DesfireAuth_Step2& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMSG_DesfireAuth_Step2& operator=(CMSG_DesfireAuth_Step2&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMSG_DesfireAuth_Step2& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMSG_DesfireAuth_Step2* internal_default_instance() {
    return reinterpret_cast<const CMSG_DesfireAuth_Step2*>(
               &_CMSG_DesfireAuth_Step2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(CMSG_DesfireAuth_Step2& a, CMSG_DesfireAuth_Step2& b) {
    a.Swap(&b);
  }
  inline void Swap(CMSG_DesfireAuth_Step2* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMSG_DesfireAuth_Step2* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CMSG_DesfireAuth_Step2* New() const final {
    return new CMSG_DesfireAuth_Step2();
  }

  CMSG_DesfireAuth_Step2* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CMSG_DesfireAuth_Step2>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CMSG_DesfireAuth_Step2& from);
  void MergeFrom(const CMSG_DesfireAuth_Step2& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMSG_DesfireAuth_Step2* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMSG_DesfireAuth_Step2";
  }
  protected:
  explicit CMSG_DesfireAuth_Step2(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyUuidFieldNumber = 1,
    kPiccCryptogramFieldNumber = 2,
    kAuthContextIdFieldNumber = 3,
    kDiversificationFieldNumber = 4,
  };
  // string key_uuid = 1;
  void clear_key_uuid();
  const std::string& key_uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key_uuid();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_key_uuid();
  void set_allocated_key_uuid(std::string* key_uuid);
  private:
  const std::string& _internal_key_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key_uuid(const std::string& value);
  std::string* _internal_mutable_key_uuid();
  public:

  // bytes picc_cryptogram = 2;
  void clear_picc_cryptogram();
  const std::string& picc_cryptogram() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_picc_cryptogram(ArgT0&& arg0, ArgT... args);
  std::string* mutable_picc_cryptogram();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_picc_cryptogram();
  void set_allocated_picc_cryptogram(std::string* picc_cryptogram);
  private:
  const std::string& _internal_picc_cryptogram() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_picc_cryptogram(const std::string& value);
  std::string* _internal_mutable_picc_cryptogram();
  public:

  // bytes auth_context_id = 3;
  void clear_auth_context_id();
  const std::string& auth_context_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_auth_context_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_auth_context_id();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_auth_context_id();
  void set_allocated_auth_context_id(std::string* auth_context_id);
  private:
  const std::string& _internal_auth_context_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_auth_context_id(const std::string& value);
  std::string* _internal_mutable_auth_context_id();
  public:

  // .KeyDiversificationInfo diversification = 4;
  bool has_diversification() const;
  private:
  bool _internal_has_diversification() const;
  public:
  void clear_diversification();
  const ::KeyDiversificationInfo& diversification() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::KeyDiversificationInfo* release_diversification();
  ::KeyDiversificationInfo* mutable_diversification();
  void set_allocated_diversification(::KeyDiversificationInfo* diversification);
  private:
  const ::KeyDiversificationInfo& _internal_diversification() const;
  ::KeyDiversificationInfo* _internal_mutable_diversification();
  public:
  void unsafe_arena_set_allocated_diversification(
      ::KeyDiversificationInfo* diversification);
  ::KeyDiversificationInfo* unsafe_arena_release_diversification();

  // @@protoc_insertion_point(class_scope:CMSG_DesfireAuth_Step2)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_uuid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr picc_cryptogram_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr auth_context_id_;
  ::KeyDiversificationInfo* diversification_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_iks_2eproto;
};
// -------------------------------------------------------------------

class SMSG_DesfireAuth_Step2 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SMSG_DesfireAuth_Step2) */ {
 public:
  inline SMSG_DesfireAuth_Step2() : SMSG_DesfireAuth_Step2(nullptr) {}
  ~SMSG_DesfireAuth_Step2() override;
  explicit constexpr SMSG_DesfireAuth_Step2(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SMSG_DesfireAuth_Step2(const SMSG_DesfireAuth_Step2& from);
  SMSG_DesfireAuth_Step2(SMSG_DesfireAuth_Step2&& from) noexcept
    : SMSG_DesfireAuth_Step2() {
    *this = ::std::move(from);
  }

  inline SMSG_DesfireAuth_Step2& operator=(const SMSG_DesfireAuth_Step2& from) {
    CopyFrom(from);
    return *this;
  }
  inline SMSG_DesfireAuth_Step2& operator=(SMSG_DesfireAuth_Step2&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SMSG_DesfireAuth_Step2& default_instance() {
    return *internal_default_instance();
  }
  static inline const SMSG_DesfireAuth_Step2* internal_default_instance() {
    return reinterpret_cast<const SMSG_DesfireAuth_Step2*>(
               &_SMSG_DesfireAuth_Step2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(SMSG_DesfireAuth_Step2& a, SMSG_DesfireAuth_Step2& b) {
    a.Swap(&b);
  }
  inline void Swap(SMSG_DesfireAuth_Step2* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SMSG_DesfireAuth_Step2* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SMSG_DesfireAuth_Step2* New() const final {
    return new SMSG_DesfireAuth_Step2();
  }

  SMSG_DesfireAuth_Step2* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SMSG_DesfireAuth_Step2>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SMSG_DesfireAuth_Step2& from);
  void MergeFrom(const SMSG_DesfireAuth_Step2& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SMSG_DesfireAuth_Step2* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SMSG_DesfireAuth_Step2";
  }
  protected:
  explicit SMSG_DesfireAuth_Step2(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionKeyFieldNumber = 2,
    kSessionKeyRefFieldNumber = 3,
    kSuccessFieldNumber = 1,
  };
  // bytes session_key = 2;
  void clear_session_key();
  const std::string& session_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session_key();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_session_key();
  void set_allocated_session_key(std::string* session_key);
  private:
  const std::string& _internal_session_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_key(const std::string& value);
  std::string* _internal_mutable_session_key();
  public:

  // string session_key_ref = 3;
  void clear_session_key_ref();
  const std::string& session_key_ref() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session_key_ref(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session_key_ref();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_session_key_ref();
  void set_allocated_session_key_ref(std::string* session_key_ref);
  private:
  const std::string& _internal_session_key_ref() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_key_ref(const std::string& value);
  std::string* _internal_mutable_session_key_ref();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:SMSG_DesfireAuth_Step2)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_key_ref_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_iks_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// KeyDiversificationInfo

// .KeyDiversificationInfo.Type div_type = 1;
inline void KeyDiversificationInfo::clear_div_type() {
  div_type_ = 0;
}
inline ::KeyDiversificationInfo_Type KeyDiversificationInfo::_internal_div_type() const {
  return static_cast< ::KeyDiversificationInfo_Type >(div_type_);
}
inline ::KeyDiversificationInfo_Type KeyDiversificationInfo::div_type() const {
  // @@protoc_insertion_point(field_get:KeyDiversificationInfo.div_type)
  return _internal_div_type();
}
inline void KeyDiversificationInfo::_internal_set_div_type(::KeyDiversificationInfo_Type value) {
  
  div_type_ = value;
}
inline void KeyDiversificationInfo::set_div_type(::KeyDiversificationInfo_Type value) {
  _internal_set_div_type(value);
  // @@protoc_insertion_point(field_set:KeyDiversificationInfo.div_type)
}

// bytes div_input = 2;
inline void KeyDiversificationInfo::clear_div_input() {
  div_input_.ClearToEmpty();
}
inline const std::string& KeyDiversificationInfo::div_input() const {
  // @@protoc_insertion_point(field_get:KeyDiversificationInfo.div_input)
  return _internal_div_input();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KeyDiversificationInfo::set_div_input(ArgT0&& arg0, ArgT... args) {
 
 div_input_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:KeyDiversificationInfo.div_input)
}
inline std::string* KeyDiversificationInfo::mutable_div_input() {
  // @@protoc_insertion_point(field_mutable:KeyDiversificationInfo.div_input)
  return _internal_mutable_div_input();
}
inline const std::string& KeyDiversificationInfo::_internal_div_input() const {
  return div_input_.Get();
}
inline void KeyDiversificationInfo::_internal_set_div_input(const std::string& value) {
  
  div_input_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* KeyDiversificationInfo::_internal_mutable_div_input() {
  
  return div_input_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* KeyDiversificationInfo::release_div_input() {
  // @@protoc_insertion_point(field_release:KeyDiversificationInfo.div_input)
  return div_input_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void KeyDiversificationInfo::set_allocated_div_input(std::string* div_input) {
  if (div_input != nullptr) {
    
  } else {
    
  }
  div_input_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), div_input,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:KeyDiversificationInfo.div_input)
}

// -------------------------------------------------------------------

// SignatureDescription

// bytes payload = 1;
inline void SignatureDescription::clear_payload() {
  payload_.ClearToEmpty();
}
inline const std::string& SignatureDescription::payload() const {
  // @@protoc_insertion_point(field_get:SignatureDescription.payload)
  return _internal_payload();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SignatureDescription::set_payload(ArgT0&& arg0, ArgT... args) {
 
 payload_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SignatureDescription.payload)
}
inline std::string* SignatureDescription::mutable_payload() {
  // @@protoc_insertion_point(field_mutable:SignatureDescription.payload)
  return _internal_mutable_payload();
}
inline const std::string& SignatureDescription::_internal_payload() const {
  return payload_.Get();
}
inline void SignatureDescription::_internal_set_payload(const std::string& value) {
  
  payload_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SignatureDescription::_internal_mutable_payload() {
  
  return payload_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SignatureDescription::release_payload() {
  // @@protoc_insertion_point(field_release:SignatureDescription.payload)
  return payload_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SignatureDescription::set_allocated_payload(std::string* payload) {
  if (payload != nullptr) {
    
  } else {
    
  }
  payload_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), payload,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:SignatureDescription.payload)
}

// uint64 nonce = 2;
inline void SignatureDescription::clear_nonce() {
  nonce_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SignatureDescription::_internal_nonce() const {
  return nonce_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SignatureDescription::nonce() const {
  // @@protoc_insertion_point(field_get:SignatureDescription.nonce)
  return _internal_nonce();
}
inline void SignatureDescription::_internal_set_nonce(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  nonce_ = value;
}
inline void SignatureDescription::set_nonce(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_nonce(value);
  // @@protoc_insertion_point(field_set:SignatureDescription.nonce)
}

// bytes run_uuid = 3;
inline void SignatureDescription::clear_run_uuid() {
  run_uuid_.ClearToEmpty();
}
inline const std::string& SignatureDescription::run_uuid() const {
  // @@protoc_insertion_point(field_get:SignatureDescription.run_uuid)
  return _internal_run_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SignatureDescription::set_run_uuid(ArgT0&& arg0, ArgT... args) {
 
 run_uuid_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SignatureDescription.run_uuid)
}
inline std::string* SignatureDescription::mutable_run_uuid() {
  // @@protoc_insertion_point(field_mutable:SignatureDescription.run_uuid)
  return _internal_mutable_run_uuid();
}
inline const std::string& SignatureDescription::_internal_run_uuid() const {
  return run_uuid_.Get();
}
inline void SignatureDescription::_internal_set_run_uuid(const std::string& value) {
  
  run_uuid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SignatureDescription::_internal_mutable_run_uuid() {
  
  return run_uuid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SignatureDescription::release_run_uuid() {
  // @@protoc_insertion_point(field_release:SignatureDescription.run_uuid)
  return run_uuid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SignatureDescription::set_allocated_run_uuid(std::string* run_uuid) {
  if (run_uuid != nullptr) {
    
  } else {
    
  }
  run_uuid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), run_uuid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:SignatureDescription.run_uuid)
}

// uint64 timestamp = 4;
inline void SignatureDescription::clear_timestamp() {
  timestamp_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SignatureDescription::_internal_timestamp() const {
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SignatureDescription::timestamp() const {
  // @@protoc_insertion_point(field_get:SignatureDescription.timestamp)
  return _internal_timestamp();
}
inline void SignatureDescription::_internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  timestamp_ = value;
}
inline void SignatureDescription::set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:SignatureDescription.timestamp)
}

// -------------------------------------------------------------------

// CMSG_DesfireChangeKey

// string old_key_uuid = 1;
inline void CMSG_DesfireChangeKey::clear_old_key_uuid() {
  old_key_uuid_.ClearToEmpty();
}
inline const std::string& CMSG_DesfireChangeKey::old_key_uuid() const {
  // @@protoc_insertion_point(field_get:CMSG_DesfireChangeKey.old_key_uuid)
  return _internal_old_key_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMSG_DesfireChangeKey::set_old_key_uuid(ArgT0&& arg0, ArgT... args) {
 
 old_key_uuid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMSG_DesfireChangeKey.old_key_uuid)
}
inline std::string* CMSG_DesfireChangeKey::mutable_old_key_uuid() {
  // @@protoc_insertion_point(field_mutable:CMSG_DesfireChangeKey.old_key_uuid)
  return _internal_mutable_old_key_uuid();
}
inline const std::string& CMSG_DesfireChangeKey::_internal_old_key_uuid() const {
  return old_key_uuid_.Get();
}
inline void CMSG_DesfireChangeKey::_internal_set_old_key_uuid(const std::string& value) {
  
  old_key_uuid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMSG_DesfireChangeKey::_internal_mutable_old_key_uuid() {
  
  return old_key_uuid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMSG_DesfireChangeKey::release_old_key_uuid() {
  // @@protoc_insertion_point(field_release:CMSG_DesfireChangeKey.old_key_uuid)
  return old_key_uuid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CMSG_DesfireChangeKey::set_allocated_old_key_uuid(std::string* old_key_uuid) {
  if (old_key_uuid != nullptr) {
    
  } else {
    
  }
  old_key_uuid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), old_key_uuid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:CMSG_DesfireChangeKey.old_key_uuid)
}

// bytes old_key_bytes = 2;
inline void CMSG_DesfireChangeKey::clear_old_key_bytes() {
  old_key_bytes_.ClearToEmpty();
}
inline const std::string& CMSG_DesfireChangeKey::old_key_bytes() const {
  // @@protoc_insertion_point(field_get:CMSG_DesfireChangeKey.old_key_bytes)
  return _internal_old_key_bytes();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMSG_DesfireChangeKey::set_old_key_bytes(ArgT0&& arg0, ArgT... args) {
 
 old_key_bytes_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMSG_DesfireChangeKey.old_key_bytes)
}
inline std::string* CMSG_DesfireChangeKey::mutable_old_key_bytes() {
  // @@protoc_insertion_point(field_mutable:CMSG_DesfireChangeKey.old_key_bytes)
  return _internal_mutable_old_key_bytes();
}
inline const std::string& CMSG_DesfireChangeKey::_internal_old_key_bytes() const {
  return old_key_bytes_.Get();
}
inline void CMSG_DesfireChangeKey::_internal_set_old_key_bytes(const std::string& value) {
  
  old_key_bytes_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMSG_DesfireChangeKey::_internal_mutable_old_key_bytes() {
  
  return old_key_bytes_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMSG_DesfireChangeKey::release_old_key_bytes() {
  // @@protoc_insertion_point(field_release:CMSG_DesfireChangeKey.old_key_bytes)
  return old_key_bytes_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CMSG_DesfireChangeKey::set_allocated_old_key_bytes(std::string* old_key_bytes) {
  if (old_key_bytes != nullptr) {
    
  } else {
    
  }
  old_key_bytes_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), old_key_bytes,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:CMSG_DesfireChangeKey.old_key_bytes)
}

// string new_key_uuid = 3;
inline void CMSG_DesfireChangeKey::clear_new_key_uuid() {
  new_key_uuid_.ClearToEmpty();
}
inline const std::string& CMSG_DesfireChangeKey::new_key_uuid() const {
  // @@protoc_insertion_point(field_get:CMSG_DesfireChangeKey.new_key_uuid)
  return _internal_new_key_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMSG_DesfireChangeKey::set_new_key_uuid(ArgT0&& arg0, ArgT... args) {
 
 new_key_uuid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMSG_DesfireChangeKey.new_key_uuid)
}
inline std::string* CMSG_DesfireChangeKey::mutable_new_key_uuid() {
  // @@protoc_insertion_point(field_mutable:CMSG_DesfireChangeKey.new_key_uuid)
  return _internal_mutable_new_key_uuid();
}
inline const std::string& CMSG_DesfireChangeKey::_internal_new_key_uuid() const {
  return new_key_uuid_.Get();
}
inline void CMSG_DesfireChangeKey::_internal_set_new_key_uuid(const std::string& value) {
  
  new_key_uuid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMSG_DesfireChangeKey::_internal_mutable_new_key_uuid() {
  
  return new_key_uuid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMSG_DesfireChangeKey::release_new_key_uuid() {
  // @@protoc_insertion_point(field_release:CMSG_DesfireChangeKey.new_key_uuid)
  return new_key_uuid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CMSG_DesfireChangeKey::set_allocated_new_key_uuid(std::string* new_key_uuid) {
  if (new_key_uuid != nullptr) {
    
  } else {
    
  }
  new_key_uuid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), new_key_uuid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:CMSG_DesfireChangeKey.new_key_uuid)
}

// bytes new_key_bytes = 4;
inline void CMSG_DesfireChangeKey::clear_new_key_bytes() {
  new_key_bytes_.ClearToEmpty();
}
inline const std::string& CMSG_DesfireChangeKey::new_key_bytes() const {
  // @@protoc_insertion_point(field_get:CMSG_DesfireChangeKey.new_key_bytes)
  return _internal_new_key_bytes();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMSG_DesfireChangeKey::set_new_key_bytes(ArgT0&& arg0, ArgT... args) {
 
 new_key_bytes_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMSG_DesfireChangeKey.new_key_bytes)
}
inline std::string* CMSG_DesfireChangeKey::mutable_new_key_bytes() {
  // @@protoc_insertion_point(field_mutable:CMSG_DesfireChangeKey.new_key_bytes)
  return _internal_mutable_new_key_bytes();
}
inline const std::string& CMSG_DesfireChangeKey::_internal_new_key_bytes() const {
  return new_key_bytes_.Get();
}
inline void CMSG_DesfireChangeKey::_internal_set_new_key_bytes(const std::string& value) {
  
  new_key_bytes_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMSG_DesfireChangeKey::_internal_mutable_new_key_bytes() {
  
  return new_key_bytes_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMSG_DesfireChangeKey::release_new_key_bytes() {
  // @@protoc_insertion_point(field_release:CMSG_DesfireChangeKey.new_key_bytes)
  return new_key_bytes_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CMSG_DesfireChangeKey::set_allocated_new_key_bytes(std::string* new_key_bytes) {
  if (new_key_bytes != nullptr) {
    
  } else {
    
  }
  new_key_bytes_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), new_key_bytes,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:CMSG_DesfireChangeKey.new_key_bytes)
}

// bool change_same_key = 5;
inline void CMSG_DesfireChangeKey::clear_change_same_key() {
  change_same_key_ = false;
}
inline bool CMSG_DesfireChangeKey::_internal_change_same_key() const {
  return change_same_key_;
}
inline bool CMSG_DesfireChangeKey::change_same_key() const {
  // @@protoc_insertion_point(field_get:CMSG_DesfireChangeKey.change_same_key)
  return _internal_change_same_key();
}
inline void CMSG_DesfireChangeKey::_internal_set_change_same_key(bool value) {
  
  change_same_key_ = value;
}
inline void CMSG_DesfireChangeKey::set_change_same_key(bool value) {
  _internal_set_change_same_key(value);
  // @@protoc_insertion_point(field_set:CMSG_DesfireChangeKey.change_same_key)
}

// string session_key_uuid = 6;
inline void CMSG_DesfireChangeKey::clear_session_key_uuid() {
  session_key_uuid_.ClearToEmpty();
}
inline const std::string& CMSG_DesfireChangeKey::session_key_uuid() const {
  // @@protoc_insertion_point(field_get:CMSG_DesfireChangeKey.session_key_uuid)
  return _internal_session_key_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMSG_DesfireChangeKey::set_session_key_uuid(ArgT0&& arg0, ArgT... args) {
 
 session_key_uuid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMSG_DesfireChangeKey.session_key_uuid)
}
inline std::string* CMSG_DesfireChangeKey::mutable_session_key_uuid() {
  // @@protoc_insertion_point(field_mutable:CMSG_DesfireChangeKey.session_key_uuid)
  return _internal_mutable_session_key_uuid();
}
inline const std::string& CMSG_DesfireChangeKey::_internal_session_key_uuid() const {
  return session_key_uuid_.Get();
}
inline void CMSG_DesfireChangeKey::_internal_set_session_key_uuid(const std::string& value) {
  
  session_key_uuid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMSG_DesfireChangeKey::_internal_mutable_session_key_uuid() {
  
  return session_key_uuid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMSG_DesfireChangeKey::release_session_key_uuid() {
  // @@protoc_insertion_point(field_release:CMSG_DesfireChangeKey.session_key_uuid)
  return session_key_uuid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CMSG_DesfireChangeKey::set_allocated_session_key_uuid(std::string* session_key_uuid) {
  if (session_key_uuid != nullptr) {
    
  } else {
    
  }
  session_key_uuid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), session_key_uuid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:CMSG_DesfireChangeKey.session_key_uuid)
}

// bytes session_key = 7;
inline void CMSG_DesfireChangeKey::clear_session_key() {
  session_key_.ClearToEmpty();
}
inline const std::string& CMSG_DesfireChangeKey::session_key() const {
  // @@protoc_insertion_point(field_get:CMSG_DesfireChangeKey.session_key)
  return _internal_session_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMSG_DesfireChangeKey::set_session_key(ArgT0&& arg0, ArgT... args) {
 
 session_key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMSG_DesfireChangeKey.session_key)
}
inline std::string* CMSG_DesfireChangeKey::mutable_session_key() {
  // @@protoc_insertion_point(field_mutable:CMSG_DesfireChangeKey.session_key)
  return _internal_mutable_session_key();
}
inline const std::string& CMSG_DesfireChangeKey::_internal_session_key() const {
  return session_key_.Get();
}
inline void CMSG_DesfireChangeKey::_internal_set_session_key(const std::string& value) {
  
  session_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMSG_DesfireChangeKey::_internal_mutable_session_key() {
  
  return session_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMSG_DesfireChangeKey::release_session_key() {
  // @@protoc_insertion_point(field_release:CMSG_DesfireChangeKey.session_key)
  return session_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CMSG_DesfireChangeKey::set_allocated_session_key(std::string* session_key) {
  if (session_key != nullptr) {
    
  } else {
    
  }
  session_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), session_key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:CMSG_DesfireChangeKey.session_key)
}

// .KeyDiversificationInfo old_key_div = 8;
inline bool CMSG_DesfireChangeKey::_internal_has_old_key_div() const {
  return this != internal_default_instance() && old_key_div_ != nullptr;
}
inline bool CMSG_DesfireChangeKey::has_old_key_div() const {
  return _internal_has_old_key_div();
}
inline void CMSG_DesfireChangeKey::clear_old_key_div() {
  if (GetArenaForAllocation() == nullptr && old_key_div_ != nullptr) {
    delete old_key_div_;
  }
  old_key_div_ = nullptr;
}
inline const ::KeyDiversificationInfo& CMSG_DesfireChangeKey::_internal_old_key_div() const {
  const ::KeyDiversificationInfo* p = old_key_div_;
  return p != nullptr ? *p : reinterpret_cast<const ::KeyDiversificationInfo&>(
      ::_KeyDiversificationInfo_default_instance_);
}
inline const ::KeyDiversificationInfo& CMSG_DesfireChangeKey::old_key_div() const {
  // @@protoc_insertion_point(field_get:CMSG_DesfireChangeKey.old_key_div)
  return _internal_old_key_div();
}
inline void CMSG_DesfireChangeKey::unsafe_arena_set_allocated_old_key_div(
    ::KeyDiversificationInfo* old_key_div) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(old_key_div_);
  }
  old_key_div_ = old_key_div;
  if (old_key_div) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CMSG_DesfireChangeKey.old_key_div)
}
inline ::KeyDiversificationInfo* CMSG_DesfireChangeKey::release_old_key_div() {
  
  ::KeyDiversificationInfo* temp = old_key_div_;
  old_key_div_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::KeyDiversificationInfo* CMSG_DesfireChangeKey::unsafe_arena_release_old_key_div() {
  // @@protoc_insertion_point(field_release:CMSG_DesfireChangeKey.old_key_div)
  
  ::KeyDiversificationInfo* temp = old_key_div_;
  old_key_div_ = nullptr;
  return temp;
}
inline ::KeyDiversificationInfo* CMSG_DesfireChangeKey::_internal_mutable_old_key_div() {
  
  if (old_key_div_ == nullptr) {
    auto* p = CreateMaybeMessage<::KeyDiversificationInfo>(GetArenaForAllocation());
    old_key_div_ = p;
  }
  return old_key_div_;
}
inline ::KeyDiversificationInfo* CMSG_DesfireChangeKey::mutable_old_key_div() {
  // @@protoc_insertion_point(field_mutable:CMSG_DesfireChangeKey.old_key_div)
  return _internal_mutable_old_key_div();
}
inline void CMSG_DesfireChangeKey::set_allocated_old_key_div(::KeyDiversificationInfo* old_key_div) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete old_key_div_;
  }
  if (old_key_div) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::KeyDiversificationInfo>::GetOwningArena(old_key_div);
    if (message_arena != submessage_arena) {
      old_key_div = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, old_key_div, submessage_arena);
    }
    
  } else {
    
  }
  old_key_div_ = old_key_div;
  // @@protoc_insertion_point(field_set_allocated:CMSG_DesfireChangeKey.old_key_div)
}

// .KeyDiversificationInfo new_key_div = 9;
inline bool CMSG_DesfireChangeKey::_internal_has_new_key_div() const {
  return this != internal_default_instance() && new_key_div_ != nullptr;
}
inline bool CMSG_DesfireChangeKey::has_new_key_div() const {
  return _internal_has_new_key_div();
}
inline void CMSG_DesfireChangeKey::clear_new_key_div() {
  if (GetArenaForAllocation() == nullptr && new_key_div_ != nullptr) {
    delete new_key_div_;
  }
  new_key_div_ = nullptr;
}
inline const ::KeyDiversificationInfo& CMSG_DesfireChangeKey::_internal_new_key_div() const {
  const ::KeyDiversificationInfo* p = new_key_div_;
  return p != nullptr ? *p : reinterpret_cast<const ::KeyDiversificationInfo&>(
      ::_KeyDiversificationInfo_default_instance_);
}
inline const ::KeyDiversificationInfo& CMSG_DesfireChangeKey::new_key_div() const {
  // @@protoc_insertion_point(field_get:CMSG_DesfireChangeKey.new_key_div)
  return _internal_new_key_div();
}
inline void CMSG_DesfireChangeKey::unsafe_arena_set_allocated_new_key_div(
    ::KeyDiversificationInfo* new_key_div) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(new_key_div_);
  }
  new_key_div_ = new_key_div;
  if (new_key_div) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CMSG_DesfireChangeKey.new_key_div)
}
inline ::KeyDiversificationInfo* CMSG_DesfireChangeKey::release_new_key_div() {
  
  ::KeyDiversificationInfo* temp = new_key_div_;
  new_key_div_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::KeyDiversificationInfo* CMSG_DesfireChangeKey::unsafe_arena_release_new_key_div() {
  // @@protoc_insertion_point(field_release:CMSG_DesfireChangeKey.new_key_div)
  
  ::KeyDiversificationInfo* temp = new_key_div_;
  new_key_div_ = nullptr;
  return temp;
}
inline ::KeyDiversificationInfo* CMSG_DesfireChangeKey::_internal_mutable_new_key_div() {
  
  if (new_key_div_ == nullptr) {
    auto* p = CreateMaybeMessage<::KeyDiversificationInfo>(GetArenaForAllocation());
    new_key_div_ = p;
  }
  return new_key_div_;
}
inline ::KeyDiversificationInfo* CMSG_DesfireChangeKey::mutable_new_key_div() {
  // @@protoc_insertion_point(field_mutable:CMSG_DesfireChangeKey.new_key_div)
  return _internal_mutable_new_key_div();
}
inline void CMSG_DesfireChangeKey::set_allocated_new_key_div(::KeyDiversificationInfo* new_key_div) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete new_key_div_;
  }
  if (new_key_div) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::KeyDiversificationInfo>::GetOwningArena(new_key_div);
    if (message_arena != submessage_arena) {
      new_key_div = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, new_key_div, submessage_arena);
    }
    
  } else {
    
  }
  new_key_div_ = new_key_div;
  // @@protoc_insertion_point(field_set_allocated:CMSG_DesfireChangeKey.new_key_div)
}

// int32 key_number = 10;
inline void CMSG_DesfireChangeKey::clear_key_number() {
  key_number_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CMSG_DesfireChangeKey::_internal_key_number() const {
  return key_number_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CMSG_DesfireChangeKey::key_number() const {
  // @@protoc_insertion_point(field_get:CMSG_DesfireChangeKey.key_number)
  return _internal_key_number();
}
inline void CMSG_DesfireChangeKey::_internal_set_key_number(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  key_number_ = value;
}
inline void CMSG_DesfireChangeKey::set_key_number(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_key_number(value);
  // @@protoc_insertion_point(field_set:CMSG_DesfireChangeKey.key_number)
}

// bytes iv = 11;
inline void CMSG_DesfireChangeKey::clear_iv() {
  iv_.ClearToEmpty();
}
inline const std::string& CMSG_DesfireChangeKey::iv() const {
  // @@protoc_insertion_point(field_get:CMSG_DesfireChangeKey.iv)
  return _internal_iv();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMSG_DesfireChangeKey::set_iv(ArgT0&& arg0, ArgT... args) {
 
 iv_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMSG_DesfireChangeKey.iv)
}
inline std::string* CMSG_DesfireChangeKey::mutable_iv() {
  // @@protoc_insertion_point(field_mutable:CMSG_DesfireChangeKey.iv)
  return _internal_mutable_iv();
}
inline const std::string& CMSG_DesfireChangeKey::_internal_iv() const {
  return iv_.Get();
}
inline void CMSG_DesfireChangeKey::_internal_set_iv(const std::string& value) {
  
  iv_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMSG_DesfireChangeKey::_internal_mutable_iv() {
  
  return iv_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMSG_DesfireChangeKey::release_iv() {
  // @@protoc_insertion_point(field_release:CMSG_DesfireChangeKey.iv)
  return iv_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CMSG_DesfireChangeKey::set_allocated_iv(std::string* iv) {
  if (iv != nullptr) {
    
  } else {
    
  }
  iv_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), iv,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:CMSG_DesfireChangeKey.iv)
}

// -------------------------------------------------------------------

// SMSG_DesfireChangeKey

// bytes cryptogram = 1;
inline void SMSG_DesfireChangeKey::clear_cryptogram() {
  cryptogram_.ClearToEmpty();
}
inline const std::string& SMSG_DesfireChangeKey::cryptogram() const {
  // @@protoc_insertion_point(field_get:SMSG_DesfireChangeKey.cryptogram)
  return _internal_cryptogram();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SMSG_DesfireChangeKey::set_cryptogram(ArgT0&& arg0, ArgT... args) {
 
 cryptogram_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SMSG_DesfireChangeKey.cryptogram)
}
inline std::string* SMSG_DesfireChangeKey::mutable_cryptogram() {
  // @@protoc_insertion_point(field_mutable:SMSG_DesfireChangeKey.cryptogram)
  return _internal_mutable_cryptogram();
}
inline const std::string& SMSG_DesfireChangeKey::_internal_cryptogram() const {
  return cryptogram_.Get();
}
inline void SMSG_DesfireChangeKey::_internal_set_cryptogram(const std::string& value) {
  
  cryptogram_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SMSG_DesfireChangeKey::_internal_mutable_cryptogram() {
  
  return cryptogram_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SMSG_DesfireChangeKey::release_cryptogram() {
  // @@protoc_insertion_point(field_release:SMSG_DesfireChangeKey.cryptogram)
  return cryptogram_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SMSG_DesfireChangeKey::set_allocated_cryptogram(std::string* cryptogram) {
  if (cryptogram != nullptr) {
    
  } else {
    
  }
  cryptogram_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cryptogram,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:SMSG_DesfireChangeKey.cryptogram)
}

// -------------------------------------------------------------------

// CMSG_GenRandom

// int32 size = 1;
inline void CMSG_GenRandom::clear_size() {
  size_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CMSG_GenRandom::_internal_size() const {
  return size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CMSG_GenRandom::size() const {
  // @@protoc_insertion_point(field_get:CMSG_GenRandom.size)
  return _internal_size();
}
inline void CMSG_GenRandom::_internal_set_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  size_ = value;
}
inline void CMSG_GenRandom::set_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:CMSG_GenRandom.size)
}

// -------------------------------------------------------------------

// SMSG_GenRandom

// bytes randomBytes = 1;
inline void SMSG_GenRandom::clear_randombytes() {
  randombytes_.ClearToEmpty();
}
inline const std::string& SMSG_GenRandom::randombytes() const {
  // @@protoc_insertion_point(field_get:SMSG_GenRandom.randomBytes)
  return _internal_randombytes();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SMSG_GenRandom::set_randombytes(ArgT0&& arg0, ArgT... args) {
 
 randombytes_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SMSG_GenRandom.randomBytes)
}
inline std::string* SMSG_GenRandom::mutable_randombytes() {
  // @@protoc_insertion_point(field_mutable:SMSG_GenRandom.randomBytes)
  return _internal_mutable_randombytes();
}
inline const std::string& SMSG_GenRandom::_internal_randombytes() const {
  return randombytes_.Get();
}
inline void SMSG_GenRandom::_internal_set_randombytes(const std::string& value) {
  
  randombytes_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SMSG_GenRandom::_internal_mutable_randombytes() {
  
  return randombytes_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SMSG_GenRandom::release_randombytes() {
  // @@protoc_insertion_point(field_release:SMSG_GenRandom.randomBytes)
  return randombytes_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SMSG_GenRandom::set_allocated_randombytes(std::string* randombytes) {
  if (randombytes != nullptr) {
    
  } else {
    
  }
  randombytes_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), randombytes,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:SMSG_GenRandom.randomBytes)
}

// -------------------------------------------------------------------

// CMSG_AESOperation

// string key_uuid = 1;
inline void CMSG_AESOperation::clear_key_uuid() {
  key_uuid_.ClearToEmpty();
}
inline const std::string& CMSG_AESOperation::key_uuid() const {
  // @@protoc_insertion_point(field_get:CMSG_AESOperation.key_uuid)
  return _internal_key_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMSG_AESOperation::set_key_uuid(ArgT0&& arg0, ArgT... args) {
 
 key_uuid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMSG_AESOperation.key_uuid)
}
inline std::string* CMSG_AESOperation::mutable_key_uuid() {
  // @@protoc_insertion_point(field_mutable:CMSG_AESOperation.key_uuid)
  return _internal_mutable_key_uuid();
}
inline const std::string& CMSG_AESOperation::_internal_key_uuid() const {
  return key_uuid_.Get();
}
inline void CMSG_AESOperation::_internal_set_key_uuid(const std::string& value) {
  
  key_uuid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMSG_AESOperation::_internal_mutable_key_uuid() {
  
  return key_uuid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMSG_AESOperation::release_key_uuid() {
  // @@protoc_insertion_point(field_release:CMSG_AESOperation.key_uuid)
  return key_uuid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CMSG_AESOperation::set_allocated_key_uuid(std::string* key_uuid) {
  if (key_uuid != nullptr) {
    
  } else {
    
  }
  key_uuid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key_uuid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:CMSG_AESOperation.key_uuid)
}

// bytes payload = 3;
inline void CMSG_AESOperation::clear_payload() {
  payload_.ClearToEmpty();
}
inline const std::string& CMSG_AESOperation::payload() const {
  // @@protoc_insertion_point(field_get:CMSG_AESOperation.payload)
  return _internal_payload();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMSG_AESOperation::set_payload(ArgT0&& arg0, ArgT... args) {
 
 payload_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMSG_AESOperation.payload)
}
inline std::string* CMSG_AESOperation::mutable_payload() {
  // @@protoc_insertion_point(field_mutable:CMSG_AESOperation.payload)
  return _internal_mutable_payload();
}
inline const std::string& CMSG_AESOperation::_internal_payload() const {
  return payload_.Get();
}
inline void CMSG_AESOperation::_internal_set_payload(const std::string& value) {
  
  payload_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMSG_AESOperation::_internal_mutable_payload() {
  
  return payload_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMSG_AESOperation::release_payload() {
  // @@protoc_insertion_point(field_release:CMSG_AESOperation.payload)
  return payload_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CMSG_AESOperation::set_allocated_payload(std::string* payload) {
  if (payload != nullptr) {
    
  } else {
    
  }
  payload_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), payload,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:CMSG_AESOperation.payload)
}

// bytes iv = 4;
inline void CMSG_AESOperation::clear_iv() {
  iv_.ClearToEmpty();
}
inline const std::string& CMSG_AESOperation::iv() const {
  // @@protoc_insertion_point(field_get:CMSG_AESOperation.iv)
  return _internal_iv();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMSG_AESOperation::set_iv(ArgT0&& arg0, ArgT... args) {
 
 iv_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMSG_AESOperation.iv)
}
inline std::string* CMSG_AESOperation::mutable_iv() {
  // @@protoc_insertion_point(field_mutable:CMSG_AESOperation.iv)
  return _internal_mutable_iv();
}
inline const std::string& CMSG_AESOperation::_internal_iv() const {
  return iv_.Get();
}
inline void CMSG_AESOperation::_internal_set_iv(const std::string& value) {
  
  iv_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMSG_AESOperation::_internal_mutable_iv() {
  
  return iv_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMSG_AESOperation::release_iv() {
  // @@protoc_insertion_point(field_release:CMSG_AESOperation.iv)
  return iv_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CMSG_AESOperation::set_allocated_iv(std::string* iv) {
  if (iv != nullptr) {
    
  } else {
    
  }
  iv_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), iv,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:CMSG_AESOperation.iv)
}

// bool request_signature = 5;
inline void CMSG_AESOperation::clear_request_signature() {
  request_signature_ = false;
}
inline bool CMSG_AESOperation::_internal_request_signature() const {
  return request_signature_;
}
inline bool CMSG_AESOperation::request_signature() const {
  // @@protoc_insertion_point(field_get:CMSG_AESOperation.request_signature)
  return _internal_request_signature();
}
inline void CMSG_AESOperation::_internal_set_request_signature(bool value) {
  
  request_signature_ = value;
}
inline void CMSG_AESOperation::set_request_signature(bool value) {
  _internal_set_request_signature(value);
  // @@protoc_insertion_point(field_set:CMSG_AESOperation.request_signature)
}

// .KeyDiversificationInfo diversification = 6;
inline bool CMSG_AESOperation::_internal_has_diversification() const {
  return this != internal_default_instance() && diversification_ != nullptr;
}
inline bool CMSG_AESOperation::has_diversification() const {
  return _internal_has_diversification();
}
inline void CMSG_AESOperation::clear_diversification() {
  if (GetArenaForAllocation() == nullptr && diversification_ != nullptr) {
    delete diversification_;
  }
  diversification_ = nullptr;
}
inline const ::KeyDiversificationInfo& CMSG_AESOperation::_internal_diversification() const {
  const ::KeyDiversificationInfo* p = diversification_;
  return p != nullptr ? *p : reinterpret_cast<const ::KeyDiversificationInfo&>(
      ::_KeyDiversificationInfo_default_instance_);
}
inline const ::KeyDiversificationInfo& CMSG_AESOperation::diversification() const {
  // @@protoc_insertion_point(field_get:CMSG_AESOperation.diversification)
  return _internal_diversification();
}
inline void CMSG_AESOperation::unsafe_arena_set_allocated_diversification(
    ::KeyDiversificationInfo* diversification) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(diversification_);
  }
  diversification_ = diversification;
  if (diversification) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CMSG_AESOperation.diversification)
}
inline ::KeyDiversificationInfo* CMSG_AESOperation::release_diversification() {
  
  ::KeyDiversificationInfo* temp = diversification_;
  diversification_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::KeyDiversificationInfo* CMSG_AESOperation::unsafe_arena_release_diversification() {
  // @@protoc_insertion_point(field_release:CMSG_AESOperation.diversification)
  
  ::KeyDiversificationInfo* temp = diversification_;
  diversification_ = nullptr;
  return temp;
}
inline ::KeyDiversificationInfo* CMSG_AESOperation::_internal_mutable_diversification() {
  
  if (diversification_ == nullptr) {
    auto* p = CreateMaybeMessage<::KeyDiversificationInfo>(GetArenaForAllocation());
    diversification_ = p;
  }
  return diversification_;
}
inline ::KeyDiversificationInfo* CMSG_AESOperation::mutable_diversification() {
  // @@protoc_insertion_point(field_mutable:CMSG_AESOperation.diversification)
  return _internal_mutable_diversification();
}
inline void CMSG_AESOperation::set_allocated_diversification(::KeyDiversificationInfo* diversification) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete diversification_;
  }
  if (diversification) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::KeyDiversificationInfo>::GetOwningArena(diversification);
    if (message_arena != submessage_arena) {
      diversification = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, diversification, submessage_arena);
    }
    
  } else {
    
  }
  diversification_ = diversification;
  // @@protoc_insertion_point(field_set_allocated:CMSG_AESOperation.diversification)
}

// -------------------------------------------------------------------

// SMSG_AESResult

// bytes payload = 1;
inline void SMSG_AESResult::clear_payload() {
  payload_.ClearToEmpty();
}
inline const std::string& SMSG_AESResult::payload() const {
  // @@protoc_insertion_point(field_get:SMSG_AESResult.payload)
  return _internal_payload();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SMSG_AESResult::set_payload(ArgT0&& arg0, ArgT... args) {
 
 payload_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SMSG_AESResult.payload)
}
inline std::string* SMSG_AESResult::mutable_payload() {
  // @@protoc_insertion_point(field_mutable:SMSG_AESResult.payload)
  return _internal_mutable_payload();
}
inline const std::string& SMSG_AESResult::_internal_payload() const {
  return payload_.Get();
}
inline void SMSG_AESResult::_internal_set_payload(const std::string& value) {
  
  payload_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SMSG_AESResult::_internal_mutable_payload() {
  
  return payload_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SMSG_AESResult::release_payload() {
  // @@protoc_insertion_point(field_release:SMSG_AESResult.payload)
  return payload_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SMSG_AESResult::set_allocated_payload(std::string* payload) {
  if (payload != nullptr) {
    
  } else {
    
  }
  payload_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), payload,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:SMSG_AESResult.payload)
}

// .SignatureDescription signatureDescription = 2;
inline bool SMSG_AESResult::_internal_has_signaturedescription() const {
  return this != internal_default_instance() && signaturedescription_ != nullptr;
}
inline bool SMSG_AESResult::has_signaturedescription() const {
  return _internal_has_signaturedescription();
}
inline void SMSG_AESResult::clear_signaturedescription() {
  if (GetArenaForAllocation() == nullptr && signaturedescription_ != nullptr) {
    delete signaturedescription_;
  }
  signaturedescription_ = nullptr;
}
inline const ::SignatureDescription& SMSG_AESResult::_internal_signaturedescription() const {
  const ::SignatureDescription* p = signaturedescription_;
  return p != nullptr ? *p : reinterpret_cast<const ::SignatureDescription&>(
      ::_SignatureDescription_default_instance_);
}
inline const ::SignatureDescription& SMSG_AESResult::signaturedescription() const {
  // @@protoc_insertion_point(field_get:SMSG_AESResult.signatureDescription)
  return _internal_signaturedescription();
}
inline void SMSG_AESResult::unsafe_arena_set_allocated_signaturedescription(
    ::SignatureDescription* signaturedescription) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(signaturedescription_);
  }
  signaturedescription_ = signaturedescription;
  if (signaturedescription) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SMSG_AESResult.signatureDescription)
}
inline ::SignatureDescription* SMSG_AESResult::release_signaturedescription() {
  
  ::SignatureDescription* temp = signaturedescription_;
  signaturedescription_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::SignatureDescription* SMSG_AESResult::unsafe_arena_release_signaturedescription() {
  // @@protoc_insertion_point(field_release:SMSG_AESResult.signatureDescription)
  
  ::SignatureDescription* temp = signaturedescription_;
  signaturedescription_ = nullptr;
  return temp;
}
inline ::SignatureDescription* SMSG_AESResult::_internal_mutable_signaturedescription() {
  
  if (signaturedescription_ == nullptr) {
    auto* p = CreateMaybeMessage<::SignatureDescription>(GetArenaForAllocation());
    signaturedescription_ = p;
  }
  return signaturedescription_;
}
inline ::SignatureDescription* SMSG_AESResult::mutable_signaturedescription() {
  // @@protoc_insertion_point(field_mutable:SMSG_AESResult.signatureDescription)
  return _internal_mutable_signaturedescription();
}
inline void SMSG_AESResult::set_allocated_signaturedescription(::SignatureDescription* signaturedescription) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete signaturedescription_;
  }
  if (signaturedescription) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::SignatureDescription>::GetOwningArena(signaturedescription);
    if (message_arena != submessage_arena) {
      signaturedescription = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, signaturedescription, submessage_arena);
    }
    
  } else {
    
  }
  signaturedescription_ = signaturedescription;
  // @@protoc_insertion_point(field_set_allocated:SMSG_AESResult.signatureDescription)
}

// bytes signature = 3;
inline void SMSG_AESResult::clear_signature() {
  signature_.ClearToEmpty();
}
inline const std::string& SMSG_AESResult::signature() const {
  // @@protoc_insertion_point(field_get:SMSG_AESResult.signature)
  return _internal_signature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SMSG_AESResult::set_signature(ArgT0&& arg0, ArgT... args) {
 
 signature_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SMSG_AESResult.signature)
}
inline std::string* SMSG_AESResult::mutable_signature() {
  // @@protoc_insertion_point(field_mutable:SMSG_AESResult.signature)
  return _internal_mutable_signature();
}
inline const std::string& SMSG_AESResult::_internal_signature() const {
  return signature_.Get();
}
inline void SMSG_AESResult::_internal_set_signature(const std::string& value) {
  
  signature_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SMSG_AESResult::_internal_mutable_signature() {
  
  return signature_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SMSG_AESResult::release_signature() {
  // @@protoc_insertion_point(field_release:SMSG_AESResult.signature)
  return signature_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SMSG_AESResult::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    
  } else {
    
  }
  signature_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signature,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:SMSG_AESResult.signature)
}

// -------------------------------------------------------------------

// CMSG_DesfireAESAuth_Step1

// string key_uuid = 1;
inline void CMSG_DesfireAESAuth_Step1::clear_key_uuid() {
  key_uuid_.ClearToEmpty();
}
inline const std::string& CMSG_DesfireAESAuth_Step1::key_uuid() const {
  // @@protoc_insertion_point(field_get:CMSG_DesfireAESAuth_Step1.key_uuid)
  return _internal_key_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMSG_DesfireAESAuth_Step1::set_key_uuid(ArgT0&& arg0, ArgT... args) {
 
 key_uuid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMSG_DesfireAESAuth_Step1.key_uuid)
}
inline std::string* CMSG_DesfireAESAuth_Step1::mutable_key_uuid() {
  // @@protoc_insertion_point(field_mutable:CMSG_DesfireAESAuth_Step1.key_uuid)
  return _internal_mutable_key_uuid();
}
inline const std::string& CMSG_DesfireAESAuth_Step1::_internal_key_uuid() const {
  return key_uuid_.Get();
}
inline void CMSG_DesfireAESAuth_Step1::_internal_set_key_uuid(const std::string& value) {
  
  key_uuid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMSG_DesfireAESAuth_Step1::_internal_mutable_key_uuid() {
  
  return key_uuid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMSG_DesfireAESAuth_Step1::release_key_uuid() {
  // @@protoc_insertion_point(field_release:CMSG_DesfireAESAuth_Step1.key_uuid)
  return key_uuid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CMSG_DesfireAESAuth_Step1::set_allocated_key_uuid(std::string* key_uuid) {
  if (key_uuid != nullptr) {
    
  } else {
    
  }
  key_uuid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key_uuid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:CMSG_DesfireAESAuth_Step1.key_uuid)
}

// bytes encrypted_random_picc = 2;
inline void CMSG_DesfireAESAuth_Step1::clear_encrypted_random_picc() {
  encrypted_random_picc_.ClearToEmpty();
}
inline const std::string& CMSG_DesfireAESAuth_Step1::encrypted_random_picc() const {
  // @@protoc_insertion_point(field_get:CMSG_DesfireAESAuth_Step1.encrypted_random_picc)
  return _internal_encrypted_random_picc();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMSG_DesfireAESAuth_Step1::set_encrypted_random_picc(ArgT0&& arg0, ArgT... args) {
 
 encrypted_random_picc_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMSG_DesfireAESAuth_Step1.encrypted_random_picc)
}
inline std::string* CMSG_DesfireAESAuth_Step1::mutable_encrypted_random_picc() {
  // @@protoc_insertion_point(field_mutable:CMSG_DesfireAESAuth_Step1.encrypted_random_picc)
  return _internal_mutable_encrypted_random_picc();
}
inline const std::string& CMSG_DesfireAESAuth_Step1::_internal_encrypted_random_picc() const {
  return encrypted_random_picc_.Get();
}
inline void CMSG_DesfireAESAuth_Step1::_internal_set_encrypted_random_picc(const std::string& value) {
  
  encrypted_random_picc_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMSG_DesfireAESAuth_Step1::_internal_mutable_encrypted_random_picc() {
  
  return encrypted_random_picc_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMSG_DesfireAESAuth_Step1::release_encrypted_random_picc() {
  // @@protoc_insertion_point(field_release:CMSG_DesfireAESAuth_Step1.encrypted_random_picc)
  return encrypted_random_picc_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CMSG_DesfireAESAuth_Step1::set_allocated_encrypted_random_picc(std::string* encrypted_random_picc) {
  if (encrypted_random_picc != nullptr) {
    
  } else {
    
  }
  encrypted_random_picc_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), encrypted_random_picc,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:CMSG_DesfireAESAuth_Step1.encrypted_random_picc)
}

// .KeyDiversificationInfo diversification = 3;
inline bool CMSG_DesfireAESAuth_Step1::_internal_has_diversification() const {
  return this != internal_default_instance() && diversification_ != nullptr;
}
inline bool CMSG_DesfireAESAuth_Step1::has_diversification() const {
  return _internal_has_diversification();
}
inline void CMSG_DesfireAESAuth_Step1::clear_diversification() {
  if (GetArenaForAllocation() == nullptr && diversification_ != nullptr) {
    delete diversification_;
  }
  diversification_ = nullptr;
}
inline const ::KeyDiversificationInfo& CMSG_DesfireAESAuth_Step1::_internal_diversification() const {
  const ::KeyDiversificationInfo* p = diversification_;
  return p != nullptr ? *p : reinterpret_cast<const ::KeyDiversificationInfo&>(
      ::_KeyDiversificationInfo_default_instance_);
}
inline const ::KeyDiversificationInfo& CMSG_DesfireAESAuth_Step1::diversification() const {
  // @@protoc_insertion_point(field_get:CMSG_DesfireAESAuth_Step1.diversification)
  return _internal_diversification();
}
inline void CMSG_DesfireAESAuth_Step1::unsafe_arena_set_allocated_diversification(
    ::KeyDiversificationInfo* diversification) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(diversification_);
  }
  diversification_ = diversification;
  if (diversification) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CMSG_DesfireAESAuth_Step1.diversification)
}
inline ::KeyDiversificationInfo* CMSG_DesfireAESAuth_Step1::release_diversification() {
  
  ::KeyDiversificationInfo* temp = diversification_;
  diversification_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::KeyDiversificationInfo* CMSG_DesfireAESAuth_Step1::unsafe_arena_release_diversification() {
  // @@protoc_insertion_point(field_release:CMSG_DesfireAESAuth_Step1.diversification)
  
  ::KeyDiversificationInfo* temp = diversification_;
  diversification_ = nullptr;
  return temp;
}
inline ::KeyDiversificationInfo* CMSG_DesfireAESAuth_Step1::_internal_mutable_diversification() {
  
  if (diversification_ == nullptr) {
    auto* p = CreateMaybeMessage<::KeyDiversificationInfo>(GetArenaForAllocation());
    diversification_ = p;
  }
  return diversification_;
}
inline ::KeyDiversificationInfo* CMSG_DesfireAESAuth_Step1::mutable_diversification() {
  // @@protoc_insertion_point(field_mutable:CMSG_DesfireAESAuth_Step1.diversification)
  return _internal_mutable_diversification();
}
inline void CMSG_DesfireAESAuth_Step1::set_allocated_diversification(::KeyDiversificationInfo* diversification) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete diversification_;
  }
  if (diversification) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::KeyDiversificationInfo>::GetOwningArena(diversification);
    if (message_arena != submessage_arena) {
      diversification = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, diversification, submessage_arena);
    }
    
  } else {
    
  }
  diversification_ = diversification;
  // @@protoc_insertion_point(field_set_allocated:CMSG_DesfireAESAuth_Step1.diversification)
}

// -------------------------------------------------------------------

// SMSG_DesfireAESAuth_Step1

// bool success = 1;
inline void SMSG_DesfireAESAuth_Step1::clear_success() {
  success_ = false;
}
inline bool SMSG_DesfireAESAuth_Step1::_internal_success() const {
  return success_;
}
inline bool SMSG_DesfireAESAuth_Step1::success() const {
  // @@protoc_insertion_point(field_get:SMSG_DesfireAESAuth_Step1.success)
  return _internal_success();
}
inline void SMSG_DesfireAESAuth_Step1::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void SMSG_DesfireAESAuth_Step1::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:SMSG_DesfireAESAuth_Step1.success)
}

// bytes encrypted_cryptogram = 3;
inline void SMSG_DesfireAESAuth_Step1::clear_encrypted_cryptogram() {
  encrypted_cryptogram_.ClearToEmpty();
}
inline const std::string& SMSG_DesfireAESAuth_Step1::encrypted_cryptogram() const {
  // @@protoc_insertion_point(field_get:SMSG_DesfireAESAuth_Step1.encrypted_cryptogram)
  return _internal_encrypted_cryptogram();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SMSG_DesfireAESAuth_Step1::set_encrypted_cryptogram(ArgT0&& arg0, ArgT... args) {
 
 encrypted_cryptogram_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SMSG_DesfireAESAuth_Step1.encrypted_cryptogram)
}
inline std::string* SMSG_DesfireAESAuth_Step1::mutable_encrypted_cryptogram() {
  // @@protoc_insertion_point(field_mutable:SMSG_DesfireAESAuth_Step1.encrypted_cryptogram)
  return _internal_mutable_encrypted_cryptogram();
}
inline const std::string& SMSG_DesfireAESAuth_Step1::_internal_encrypted_cryptogram() const {
  return encrypted_cryptogram_.Get();
}
inline void SMSG_DesfireAESAuth_Step1::_internal_set_encrypted_cryptogram(const std::string& value) {
  
  encrypted_cryptogram_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SMSG_DesfireAESAuth_Step1::_internal_mutable_encrypted_cryptogram() {
  
  return encrypted_cryptogram_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SMSG_DesfireAESAuth_Step1::release_encrypted_cryptogram() {
  // @@protoc_insertion_point(field_release:SMSG_DesfireAESAuth_Step1.encrypted_cryptogram)
  return encrypted_cryptogram_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SMSG_DesfireAESAuth_Step1::set_allocated_encrypted_cryptogram(std::string* encrypted_cryptogram) {
  if (encrypted_cryptogram != nullptr) {
    
  } else {
    
  }
  encrypted_cryptogram_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), encrypted_cryptogram,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:SMSG_DesfireAESAuth_Step1.encrypted_cryptogram)
}

// bytes auth_context_id = 4;
inline void SMSG_DesfireAESAuth_Step1::clear_auth_context_id() {
  auth_context_id_.ClearToEmpty();
}
inline const std::string& SMSG_DesfireAESAuth_Step1::auth_context_id() const {
  // @@protoc_insertion_point(field_get:SMSG_DesfireAESAuth_Step1.auth_context_id)
  return _internal_auth_context_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SMSG_DesfireAESAuth_Step1::set_auth_context_id(ArgT0&& arg0, ArgT... args) {
 
 auth_context_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SMSG_DesfireAESAuth_Step1.auth_context_id)
}
inline std::string* SMSG_DesfireAESAuth_Step1::mutable_auth_context_id() {
  // @@protoc_insertion_point(field_mutable:SMSG_DesfireAESAuth_Step1.auth_context_id)
  return _internal_mutable_auth_context_id();
}
inline const std::string& SMSG_DesfireAESAuth_Step1::_internal_auth_context_id() const {
  return auth_context_id_.Get();
}
inline void SMSG_DesfireAESAuth_Step1::_internal_set_auth_context_id(const std::string& value) {
  
  auth_context_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SMSG_DesfireAESAuth_Step1::_internal_mutable_auth_context_id() {
  
  return auth_context_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SMSG_DesfireAESAuth_Step1::release_auth_context_id() {
  // @@protoc_insertion_point(field_release:SMSG_DesfireAESAuth_Step1.auth_context_id)
  return auth_context_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SMSG_DesfireAESAuth_Step1::set_allocated_auth_context_id(std::string* auth_context_id) {
  if (auth_context_id != nullptr) {
    
  } else {
    
  }
  auth_context_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), auth_context_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:SMSG_DesfireAESAuth_Step1.auth_context_id)
}

// -------------------------------------------------------------------

// CMSG_DesfireISOAuth_Step1

// string key_uuid = 1;
inline void CMSG_DesfireISOAuth_Step1::clear_key_uuid() {
  key_uuid_.ClearToEmpty();
}
inline const std::string& CMSG_DesfireISOAuth_Step1::key_uuid() const {
  // @@protoc_insertion_point(field_get:CMSG_DesfireISOAuth_Step1.key_uuid)
  return _internal_key_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMSG_DesfireISOAuth_Step1::set_key_uuid(ArgT0&& arg0, ArgT... args) {
 
 key_uuid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMSG_DesfireISOAuth_Step1.key_uuid)
}
inline std::string* CMSG_DesfireISOAuth_Step1::mutable_key_uuid() {
  // @@protoc_insertion_point(field_mutable:CMSG_DesfireISOAuth_Step1.key_uuid)
  return _internal_mutable_key_uuid();
}
inline const std::string& CMSG_DesfireISOAuth_Step1::_internal_key_uuid() const {
  return key_uuid_.Get();
}
inline void CMSG_DesfireISOAuth_Step1::_internal_set_key_uuid(const std::string& value) {
  
  key_uuid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMSG_DesfireISOAuth_Step1::_internal_mutable_key_uuid() {
  
  return key_uuid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMSG_DesfireISOAuth_Step1::release_key_uuid() {
  // @@protoc_insertion_point(field_release:CMSG_DesfireISOAuth_Step1.key_uuid)
  return key_uuid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CMSG_DesfireISOAuth_Step1::set_allocated_key_uuid(std::string* key_uuid) {
  if (key_uuid != nullptr) {
    
  } else {
    
  }
  key_uuid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key_uuid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:CMSG_DesfireISOAuth_Step1.key_uuid)
}

// bytes random_picc = 2;
inline void CMSG_DesfireISOAuth_Step1::clear_random_picc() {
  random_picc_.ClearToEmpty();
}
inline const std::string& CMSG_DesfireISOAuth_Step1::random_picc() const {
  // @@protoc_insertion_point(field_get:CMSG_DesfireISOAuth_Step1.random_picc)
  return _internal_random_picc();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMSG_DesfireISOAuth_Step1::set_random_picc(ArgT0&& arg0, ArgT... args) {
 
 random_picc_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMSG_DesfireISOAuth_Step1.random_picc)
}
inline std::string* CMSG_DesfireISOAuth_Step1::mutable_random_picc() {
  // @@protoc_insertion_point(field_mutable:CMSG_DesfireISOAuth_Step1.random_picc)
  return _internal_mutable_random_picc();
}
inline const std::string& CMSG_DesfireISOAuth_Step1::_internal_random_picc() const {
  return random_picc_.Get();
}
inline void CMSG_DesfireISOAuth_Step1::_internal_set_random_picc(const std::string& value) {
  
  random_picc_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMSG_DesfireISOAuth_Step1::_internal_mutable_random_picc() {
  
  return random_picc_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMSG_DesfireISOAuth_Step1::release_random_picc() {
  // @@protoc_insertion_point(field_release:CMSG_DesfireISOAuth_Step1.random_picc)
  return random_picc_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CMSG_DesfireISOAuth_Step1::set_allocated_random_picc(std::string* random_picc) {
  if (random_picc != nullptr) {
    
  } else {
    
  }
  random_picc_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), random_picc,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:CMSG_DesfireISOAuth_Step1.random_picc)
}

// .KeyDiversificationInfo diversification = 3;
inline bool CMSG_DesfireISOAuth_Step1::_internal_has_diversification() const {
  return this != internal_default_instance() && diversification_ != nullptr;
}
inline bool CMSG_DesfireISOAuth_Step1::has_diversification() const {
  return _internal_has_diversification();
}
inline void CMSG_DesfireISOAuth_Step1::clear_diversification() {
  if (GetArenaForAllocation() == nullptr && diversification_ != nullptr) {
    delete diversification_;
  }
  diversification_ = nullptr;
}
inline const ::KeyDiversificationInfo& CMSG_DesfireISOAuth_Step1::_internal_diversification() const {
  const ::KeyDiversificationInfo* p = diversification_;
  return p != nullptr ? *p : reinterpret_cast<const ::KeyDiversificationInfo&>(
      ::_KeyDiversificationInfo_default_instance_);
}
inline const ::KeyDiversificationInfo& CMSG_DesfireISOAuth_Step1::diversification() const {
  // @@protoc_insertion_point(field_get:CMSG_DesfireISOAuth_Step1.diversification)
  return _internal_diversification();
}
inline void CMSG_DesfireISOAuth_Step1::unsafe_arena_set_allocated_diversification(
    ::KeyDiversificationInfo* diversification) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(diversification_);
  }
  diversification_ = diversification;
  if (diversification) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CMSG_DesfireISOAuth_Step1.diversification)
}
inline ::KeyDiversificationInfo* CMSG_DesfireISOAuth_Step1::release_diversification() {
  
  ::KeyDiversificationInfo* temp = diversification_;
  diversification_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::KeyDiversificationInfo* CMSG_DesfireISOAuth_Step1::unsafe_arena_release_diversification() {
  // @@protoc_insertion_point(field_release:CMSG_DesfireISOAuth_Step1.diversification)
  
  ::KeyDiversificationInfo* temp = diversification_;
  diversification_ = nullptr;
  return temp;
}
inline ::KeyDiversificationInfo* CMSG_DesfireISOAuth_Step1::_internal_mutable_diversification() {
  
  if (diversification_ == nullptr) {
    auto* p = CreateMaybeMessage<::KeyDiversificationInfo>(GetArenaForAllocation());
    diversification_ = p;
  }
  return diversification_;
}
inline ::KeyDiversificationInfo* CMSG_DesfireISOAuth_Step1::mutable_diversification() {
  // @@protoc_insertion_point(field_mutable:CMSG_DesfireISOAuth_Step1.diversification)
  return _internal_mutable_diversification();
}
inline void CMSG_DesfireISOAuth_Step1::set_allocated_diversification(::KeyDiversificationInfo* diversification) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete diversification_;
  }
  if (diversification) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::KeyDiversificationInfo>::GetOwningArena(diversification);
    if (message_arena != submessage_arena) {
      diversification = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, diversification, submessage_arena);
    }
    
  } else {
    
  }
  diversification_ = diversification;
  // @@protoc_insertion_point(field_set_allocated:CMSG_DesfireISOAuth_Step1.diversification)
}

// -------------------------------------------------------------------

// SMSG_DesfireISOAuth_Step1

// bool success = 1;
inline void SMSG_DesfireISOAuth_Step1::clear_success() {
  success_ = false;
}
inline bool SMSG_DesfireISOAuth_Step1::_internal_success() const {
  return success_;
}
inline bool SMSG_DesfireISOAuth_Step1::success() const {
  // @@protoc_insertion_point(field_get:SMSG_DesfireISOAuth_Step1.success)
  return _internal_success();
}
inline void SMSG_DesfireISOAuth_Step1::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void SMSG_DesfireISOAuth_Step1::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:SMSG_DesfireISOAuth_Step1.success)
}

// bytes random2 = 2;
inline void SMSG_DesfireISOAuth_Step1::clear_random2() {
  random2_.ClearToEmpty();
}
inline const std::string& SMSG_DesfireISOAuth_Step1::random2() const {
  // @@protoc_insertion_point(field_get:SMSG_DesfireISOAuth_Step1.random2)
  return _internal_random2();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SMSG_DesfireISOAuth_Step1::set_random2(ArgT0&& arg0, ArgT... args) {
 
 random2_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SMSG_DesfireISOAuth_Step1.random2)
}
inline std::string* SMSG_DesfireISOAuth_Step1::mutable_random2() {
  // @@protoc_insertion_point(field_mutable:SMSG_DesfireISOAuth_Step1.random2)
  return _internal_mutable_random2();
}
inline const std::string& SMSG_DesfireISOAuth_Step1::_internal_random2() const {
  return random2_.Get();
}
inline void SMSG_DesfireISOAuth_Step1::_internal_set_random2(const std::string& value) {
  
  random2_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SMSG_DesfireISOAuth_Step1::_internal_mutable_random2() {
  
  return random2_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SMSG_DesfireISOAuth_Step1::release_random2() {
  // @@protoc_insertion_point(field_release:SMSG_DesfireISOAuth_Step1.random2)
  return random2_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SMSG_DesfireISOAuth_Step1::set_allocated_random2(std::string* random2) {
  if (random2 != nullptr) {
    
  } else {
    
  }
  random2_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), random2,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:SMSG_DesfireISOAuth_Step1.random2)
}

// bytes encrypted_cryptogram = 3;
inline void SMSG_DesfireISOAuth_Step1::clear_encrypted_cryptogram() {
  encrypted_cryptogram_.ClearToEmpty();
}
inline const std::string& SMSG_DesfireISOAuth_Step1::encrypted_cryptogram() const {
  // @@protoc_insertion_point(field_get:SMSG_DesfireISOAuth_Step1.encrypted_cryptogram)
  return _internal_encrypted_cryptogram();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SMSG_DesfireISOAuth_Step1::set_encrypted_cryptogram(ArgT0&& arg0, ArgT... args) {
 
 encrypted_cryptogram_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SMSG_DesfireISOAuth_Step1.encrypted_cryptogram)
}
inline std::string* SMSG_DesfireISOAuth_Step1::mutable_encrypted_cryptogram() {
  // @@protoc_insertion_point(field_mutable:SMSG_DesfireISOAuth_Step1.encrypted_cryptogram)
  return _internal_mutable_encrypted_cryptogram();
}
inline const std::string& SMSG_DesfireISOAuth_Step1::_internal_encrypted_cryptogram() const {
  return encrypted_cryptogram_.Get();
}
inline void SMSG_DesfireISOAuth_Step1::_internal_set_encrypted_cryptogram(const std::string& value) {
  
  encrypted_cryptogram_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SMSG_DesfireISOAuth_Step1::_internal_mutable_encrypted_cryptogram() {
  
  return encrypted_cryptogram_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SMSG_DesfireISOAuth_Step1::release_encrypted_cryptogram() {
  // @@protoc_insertion_point(field_release:SMSG_DesfireISOAuth_Step1.encrypted_cryptogram)
  return encrypted_cryptogram_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SMSG_DesfireISOAuth_Step1::set_allocated_encrypted_cryptogram(std::string* encrypted_cryptogram) {
  if (encrypted_cryptogram != nullptr) {
    
  } else {
    
  }
  encrypted_cryptogram_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), encrypted_cryptogram,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:SMSG_DesfireISOAuth_Step1.encrypted_cryptogram)
}

// bytes auth_context_id = 4;
inline void SMSG_DesfireISOAuth_Step1::clear_auth_context_id() {
  auth_context_id_.ClearToEmpty();
}
inline const std::string& SMSG_DesfireISOAuth_Step1::auth_context_id() const {
  // @@protoc_insertion_point(field_get:SMSG_DesfireISOAuth_Step1.auth_context_id)
  return _internal_auth_context_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SMSG_DesfireISOAuth_Step1::set_auth_context_id(ArgT0&& arg0, ArgT... args) {
 
 auth_context_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SMSG_DesfireISOAuth_Step1.auth_context_id)
}
inline std::string* SMSG_DesfireISOAuth_Step1::mutable_auth_context_id() {
  // @@protoc_insertion_point(field_mutable:SMSG_DesfireISOAuth_Step1.auth_context_id)
  return _internal_mutable_auth_context_id();
}
inline const std::string& SMSG_DesfireISOAuth_Step1::_internal_auth_context_id() const {
  return auth_context_id_.Get();
}
inline void SMSG_DesfireISOAuth_Step1::_internal_set_auth_context_id(const std::string& value) {
  
  auth_context_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SMSG_DesfireISOAuth_Step1::_internal_mutable_auth_context_id() {
  
  return auth_context_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SMSG_DesfireISOAuth_Step1::release_auth_context_id() {
  // @@protoc_insertion_point(field_release:SMSG_DesfireISOAuth_Step1.auth_context_id)
  return auth_context_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SMSG_DesfireISOAuth_Step1::set_allocated_auth_context_id(std::string* auth_context_id) {
  if (auth_context_id != nullptr) {
    
  } else {
    
  }
  auth_context_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), auth_context_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:SMSG_DesfireISOAuth_Step1.auth_context_id)
}

// -------------------------------------------------------------------

// CMSG_DesfireAuth_Step2

// string key_uuid = 1;
inline void CMSG_DesfireAuth_Step2::clear_key_uuid() {
  key_uuid_.ClearToEmpty();
}
inline const std::string& CMSG_DesfireAuth_Step2::key_uuid() const {
  // @@protoc_insertion_point(field_get:CMSG_DesfireAuth_Step2.key_uuid)
  return _internal_key_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMSG_DesfireAuth_Step2::set_key_uuid(ArgT0&& arg0, ArgT... args) {
 
 key_uuid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMSG_DesfireAuth_Step2.key_uuid)
}
inline std::string* CMSG_DesfireAuth_Step2::mutable_key_uuid() {
  // @@protoc_insertion_point(field_mutable:CMSG_DesfireAuth_Step2.key_uuid)
  return _internal_mutable_key_uuid();
}
inline const std::string& CMSG_DesfireAuth_Step2::_internal_key_uuid() const {
  return key_uuid_.Get();
}
inline void CMSG_DesfireAuth_Step2::_internal_set_key_uuid(const std::string& value) {
  
  key_uuid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMSG_DesfireAuth_Step2::_internal_mutable_key_uuid() {
  
  return key_uuid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMSG_DesfireAuth_Step2::release_key_uuid() {
  // @@protoc_insertion_point(field_release:CMSG_DesfireAuth_Step2.key_uuid)
  return key_uuid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CMSG_DesfireAuth_Step2::set_allocated_key_uuid(std::string* key_uuid) {
  if (key_uuid != nullptr) {
    
  } else {
    
  }
  key_uuid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key_uuid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:CMSG_DesfireAuth_Step2.key_uuid)
}

// bytes picc_cryptogram = 2;
inline void CMSG_DesfireAuth_Step2::clear_picc_cryptogram() {
  picc_cryptogram_.ClearToEmpty();
}
inline const std::string& CMSG_DesfireAuth_Step2::picc_cryptogram() const {
  // @@protoc_insertion_point(field_get:CMSG_DesfireAuth_Step2.picc_cryptogram)
  return _internal_picc_cryptogram();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMSG_DesfireAuth_Step2::set_picc_cryptogram(ArgT0&& arg0, ArgT... args) {
 
 picc_cryptogram_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMSG_DesfireAuth_Step2.picc_cryptogram)
}
inline std::string* CMSG_DesfireAuth_Step2::mutable_picc_cryptogram() {
  // @@protoc_insertion_point(field_mutable:CMSG_DesfireAuth_Step2.picc_cryptogram)
  return _internal_mutable_picc_cryptogram();
}
inline const std::string& CMSG_DesfireAuth_Step2::_internal_picc_cryptogram() const {
  return picc_cryptogram_.Get();
}
inline void CMSG_DesfireAuth_Step2::_internal_set_picc_cryptogram(const std::string& value) {
  
  picc_cryptogram_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMSG_DesfireAuth_Step2::_internal_mutable_picc_cryptogram() {
  
  return picc_cryptogram_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMSG_DesfireAuth_Step2::release_picc_cryptogram() {
  // @@protoc_insertion_point(field_release:CMSG_DesfireAuth_Step2.picc_cryptogram)
  return picc_cryptogram_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CMSG_DesfireAuth_Step2::set_allocated_picc_cryptogram(std::string* picc_cryptogram) {
  if (picc_cryptogram != nullptr) {
    
  } else {
    
  }
  picc_cryptogram_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), picc_cryptogram,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:CMSG_DesfireAuth_Step2.picc_cryptogram)
}

// bytes auth_context_id = 3;
inline void CMSG_DesfireAuth_Step2::clear_auth_context_id() {
  auth_context_id_.ClearToEmpty();
}
inline const std::string& CMSG_DesfireAuth_Step2::auth_context_id() const {
  // @@protoc_insertion_point(field_get:CMSG_DesfireAuth_Step2.auth_context_id)
  return _internal_auth_context_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMSG_DesfireAuth_Step2::set_auth_context_id(ArgT0&& arg0, ArgT... args) {
 
 auth_context_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMSG_DesfireAuth_Step2.auth_context_id)
}
inline std::string* CMSG_DesfireAuth_Step2::mutable_auth_context_id() {
  // @@protoc_insertion_point(field_mutable:CMSG_DesfireAuth_Step2.auth_context_id)
  return _internal_mutable_auth_context_id();
}
inline const std::string& CMSG_DesfireAuth_Step2::_internal_auth_context_id() const {
  return auth_context_id_.Get();
}
inline void CMSG_DesfireAuth_Step2::_internal_set_auth_context_id(const std::string& value) {
  
  auth_context_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMSG_DesfireAuth_Step2::_internal_mutable_auth_context_id() {
  
  return auth_context_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMSG_DesfireAuth_Step2::release_auth_context_id() {
  // @@protoc_insertion_point(field_release:CMSG_DesfireAuth_Step2.auth_context_id)
  return auth_context_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CMSG_DesfireAuth_Step2::set_allocated_auth_context_id(std::string* auth_context_id) {
  if (auth_context_id != nullptr) {
    
  } else {
    
  }
  auth_context_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), auth_context_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:CMSG_DesfireAuth_Step2.auth_context_id)
}

// .KeyDiversificationInfo diversification = 4;
inline bool CMSG_DesfireAuth_Step2::_internal_has_diversification() const {
  return this != internal_default_instance() && diversification_ != nullptr;
}
inline bool CMSG_DesfireAuth_Step2::has_diversification() const {
  return _internal_has_diversification();
}
inline void CMSG_DesfireAuth_Step2::clear_diversification() {
  if (GetArenaForAllocation() == nullptr && diversification_ != nullptr) {
    delete diversification_;
  }
  diversification_ = nullptr;
}
inline const ::KeyDiversificationInfo& CMSG_DesfireAuth_Step2::_internal_diversification() const {
  const ::KeyDiversificationInfo* p = diversification_;
  return p != nullptr ? *p : reinterpret_cast<const ::KeyDiversificationInfo&>(
      ::_KeyDiversificationInfo_default_instance_);
}
inline const ::KeyDiversificationInfo& CMSG_DesfireAuth_Step2::diversification() const {
  // @@protoc_insertion_point(field_get:CMSG_DesfireAuth_Step2.diversification)
  return _internal_diversification();
}
inline void CMSG_DesfireAuth_Step2::unsafe_arena_set_allocated_diversification(
    ::KeyDiversificationInfo* diversification) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(diversification_);
  }
  diversification_ = diversification;
  if (diversification) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CMSG_DesfireAuth_Step2.diversification)
}
inline ::KeyDiversificationInfo* CMSG_DesfireAuth_Step2::release_diversification() {
  
  ::KeyDiversificationInfo* temp = diversification_;
  diversification_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::KeyDiversificationInfo* CMSG_DesfireAuth_Step2::unsafe_arena_release_diversification() {
  // @@protoc_insertion_point(field_release:CMSG_DesfireAuth_Step2.diversification)
  
  ::KeyDiversificationInfo* temp = diversification_;
  diversification_ = nullptr;
  return temp;
}
inline ::KeyDiversificationInfo* CMSG_DesfireAuth_Step2::_internal_mutable_diversification() {
  
  if (diversification_ == nullptr) {
    auto* p = CreateMaybeMessage<::KeyDiversificationInfo>(GetArenaForAllocation());
    diversification_ = p;
  }
  return diversification_;
}
inline ::KeyDiversificationInfo* CMSG_DesfireAuth_Step2::mutable_diversification() {
  // @@protoc_insertion_point(field_mutable:CMSG_DesfireAuth_Step2.diversification)
  return _internal_mutable_diversification();
}
inline void CMSG_DesfireAuth_Step2::set_allocated_diversification(::KeyDiversificationInfo* diversification) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete diversification_;
  }
  if (diversification) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::KeyDiversificationInfo>::GetOwningArena(diversification);
    if (message_arena != submessage_arena) {
      diversification = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, diversification, submessage_arena);
    }
    
  } else {
    
  }
  diversification_ = diversification;
  // @@protoc_insertion_point(field_set_allocated:CMSG_DesfireAuth_Step2.diversification)
}

// -------------------------------------------------------------------

// SMSG_DesfireAuth_Step2

// bool success = 1;
inline void SMSG_DesfireAuth_Step2::clear_success() {
  success_ = false;
}
inline bool SMSG_DesfireAuth_Step2::_internal_success() const {
  return success_;
}
inline bool SMSG_DesfireAuth_Step2::success() const {
  // @@protoc_insertion_point(field_get:SMSG_DesfireAuth_Step2.success)
  return _internal_success();
}
inline void SMSG_DesfireAuth_Step2::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void SMSG_DesfireAuth_Step2::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:SMSG_DesfireAuth_Step2.success)
}

// bytes session_key = 2;
inline void SMSG_DesfireAuth_Step2::clear_session_key() {
  session_key_.ClearToEmpty();
}
inline const std::string& SMSG_DesfireAuth_Step2::session_key() const {
  // @@protoc_insertion_point(field_get:SMSG_DesfireAuth_Step2.session_key)
  return _internal_session_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SMSG_DesfireAuth_Step2::set_session_key(ArgT0&& arg0, ArgT... args) {
 
 session_key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SMSG_DesfireAuth_Step2.session_key)
}
inline std::string* SMSG_DesfireAuth_Step2::mutable_session_key() {
  // @@protoc_insertion_point(field_mutable:SMSG_DesfireAuth_Step2.session_key)
  return _internal_mutable_session_key();
}
inline const std::string& SMSG_DesfireAuth_Step2::_internal_session_key() const {
  return session_key_.Get();
}
inline void SMSG_DesfireAuth_Step2::_internal_set_session_key(const std::string& value) {
  
  session_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SMSG_DesfireAuth_Step2::_internal_mutable_session_key() {
  
  return session_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SMSG_DesfireAuth_Step2::release_session_key() {
  // @@protoc_insertion_point(field_release:SMSG_DesfireAuth_Step2.session_key)
  return session_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SMSG_DesfireAuth_Step2::set_allocated_session_key(std::string* session_key) {
  if (session_key != nullptr) {
    
  } else {
    
  }
  session_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), session_key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:SMSG_DesfireAuth_Step2.session_key)
}

// string session_key_ref = 3;
inline void SMSG_DesfireAuth_Step2::clear_session_key_ref() {
  session_key_ref_.ClearToEmpty();
}
inline const std::string& SMSG_DesfireAuth_Step2::session_key_ref() const {
  // @@protoc_insertion_point(field_get:SMSG_DesfireAuth_Step2.session_key_ref)
  return _internal_session_key_ref();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SMSG_DesfireAuth_Step2::set_session_key_ref(ArgT0&& arg0, ArgT... args) {
 
 session_key_ref_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SMSG_DesfireAuth_Step2.session_key_ref)
}
inline std::string* SMSG_DesfireAuth_Step2::mutable_session_key_ref() {
  // @@protoc_insertion_point(field_mutable:SMSG_DesfireAuth_Step2.session_key_ref)
  return _internal_mutable_session_key_ref();
}
inline const std::string& SMSG_DesfireAuth_Step2::_internal_session_key_ref() const {
  return session_key_ref_.Get();
}
inline void SMSG_DesfireAuth_Step2::_internal_set_session_key_ref(const std::string& value) {
  
  session_key_ref_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SMSG_DesfireAuth_Step2::_internal_mutable_session_key_ref() {
  
  return session_key_ref_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SMSG_DesfireAuth_Step2::release_session_key_ref() {
  // @@protoc_insertion_point(field_release:SMSG_DesfireAuth_Step2.session_key_ref)
  return session_key_ref_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SMSG_DesfireAuth_Step2::set_allocated_session_key_ref(std::string* session_key_ref) {
  if (session_key_ref != nullptr) {
    
  } else {
    
  }
  session_key_ref_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), session_key_ref,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:SMSG_DesfireAuth_Step2.session_key_ref)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::KeyDiversificationInfo_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::KeyDiversificationInfo_Type>() {
  return ::KeyDiversificationInfo_Type_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_iks_2eproto
